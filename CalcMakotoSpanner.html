<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- ã‚¿ã‚¤ãƒˆãƒ«ã‚’WSãƒªãƒ¼ã‚µãƒ«è¨ˆç®—æ©Ÿ Proã«å¤‰æ›´ -->
    <title>WSãƒªãƒ¼ã‚µãƒ«è¨ˆç®—æ©Ÿ Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- ç”»åƒå‡ºåŠ›æ©Ÿèƒ½ã®ãŸã‚ã«html2canvasã‚’è¿½åŠ  -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script> 
    <style>
        /* ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚¿ã‚¤ãƒ« */
        .card-shadow {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        /* çµæœã®æ£’ã‚°ãƒ©ãƒ•ãŒçµæœã‚¨ãƒªã‚¢å…¨ä½“ã‚’ä½¿ã†ã‚ˆã†ã«ã™ã‚‹ */
        #resultsOutput {
            min-height: 250px; /* ã‚ã‚‹ç¨‹åº¦ã®é«˜ã•ã‚’ç¢ºä¿ */
        }
        /* ãƒ¢ãƒ¼ãƒ€ãƒ«ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ */
        .modal-enter {
            opacity: 0;
        }
        .modal-enter-active {
            opacity: 1;
            transition: opacity 300ms;
        }
        .modal-leave-active {
            opacity: 0;
            transition: opacity 300ms;
        }
        .modal-content-enter {
            transform: scale(0.95);
        }
        .modal-content-enter-active {
            transform: scale(1);
            transition: transform 300ms;
        }
        /* ãƒ•ã‚©ãƒ³ãƒˆ */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 sm:p-8 font-sans">

    <div id="app" class="max-w-6xl mx-auto">
        <header class="text-center mb-10 p-4 bg-white rounded-xl shadow-lg">
            <h1 class="text-3xl font-extrabold text-indigo-700">WSãƒªãƒ¼ã‚µãƒ«è¨ˆç®—æ©Ÿ Pro</h1>
            <!-- ä»®å®Ÿè£…ã®æ³¨é‡ˆã‚’æ›´æ–° -->
            <p class="text-sm text-gray-600 mt-2">ï¼ˆãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒ»å±±å‰Šã‚Šå¯¾å¿œç‰ˆï¼‰</p>
        </header>

        <!-- ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’ã‚°ãƒªãƒƒãƒ‰ã«å¤‰æ›´ã—ã€lg:col-spanã§å·¦å³ã«åˆ†å‰² -->
        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- è¨­å®šå…¥åŠ›ã‚¨ãƒªã‚¢ (lg:col-span-1) -->
            <div class="lg:col-span-1 p-6 bg-white rounded-xl card-shadow h-fit">
                <h2 class="text-xl font-bold mb-4 text-gray-800 border-b pb-2">ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š</h2>
                
                <div class="space-y-4">
                    <!-- å±±æœ­è¨­å®š -->
                    <fieldset class="border rounded-lg p-3">
                        <legend class="text-sm font-medium text-gray-700 px-1">å±±æœ­</legend>
                        <div class="space-y-3 mt-1">
                            <div>
                                <label for="deckSize" class="block text-sm font-medium text-gray-700">åˆæœŸå±±æœ­æšæ•°</label>
                                <input type="number" id="deckSize" value="28" min="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border">
                            </div>
                            <div>
                                <label for="cxCount" class="block text-sm font-medium text-gray-700">å±±æœ­ã®CXæšæ•°</label>
                                <input type="number" id="cxCount" value="8" min="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border">
                            </div>
                        </div>
                    </fieldset>

                    <!-- â–¼â–¼â–¼ æ§ãˆå®¤è¨­å®š (æ–°è¦è¿½åŠ ) â–¼â–¼â–¼ -->
                    <fieldset class="border rounded-lg p-3">
                        <legend class="text-sm font-medium text-gray-700 px-1">æ§ãˆå®¤</legend>
                        <div class="space-y-3 mt-1">
                            <div>
                                <label for="discardCxCount" class="block text-sm font-medium text-gray-700">åˆæœŸ æ§ãˆå®¤CXæšæ•°</label>
                                <input type="number" id="discardCxCount" value="0" min="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border">
                            </div>
                            <div>
                                <label for="discardUnCxCount" class="block text-sm font-medium text-gray-700">åˆæœŸ æ§ãˆå®¤éCXæšæ•°</label>
                                <input type="number" id="discardUnCxCount" value="0" min="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border">
                            </div>
                        </div>
                    </fieldset>
                    <!-- â–²â–²â–² æ§ãˆå®¤è¨­å®š (æ–°è¦è¿½åŠ ) â–²â–²â–² -->


                    <!-- ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ— (èª¬æ˜ãƒœã‚¿ãƒ³ã‚’è¿½åŠ ) -->
                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <label for="damages" class="block text-sm font-medium text-gray-700">å®Ÿè¡Œã‚¢ã‚¯ã‚·ãƒ§ãƒ³åˆ—</label>
                            <button onclick="showExplanationModal()" class="text-xs font-semibold text-indigo-600 hover:text-indigo-800 underline">
                                èª¬æ˜ã‚’è¦‹ã‚‹
                            </button>
                        </div>
                        <input type="text" id="damages" value="1,3,3,3" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border" placeholder="ä¾‹: 3k,4,3c,2m,1b">
                    </div>

                    <!-- ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒ€ãƒ¡ãƒ¼ã‚¸ON/OFF -->
                    <div class="flex items-center pt-2">
                        <input type="checkbox" id="refreshToggle" checked class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                        <label for="refreshToggle" class="ml-2 block text-sm font-medium text-gray-700">ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒã‚¤ãƒ³ãƒˆã‚’é©ç”¨</label>
                    </div>

                    <!-- ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å›æ•° -->
                    <div>
                        <label for="simulations" class="block text-sm font-medium text-gray-700">ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å›æ•°(1000ä»¥ä¸Šã‚’æ¨å¥¨)</label>
                        <input type="number" id="simulations" value="50000" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border">
                    </div>
                    
                    <!-- ç”»åƒå‡ºåŠ›æ™‚ã®æœ€å¤§è¡¨ç¤ºç‚¹æ•° -->
                    <div>
                        <label for="imageMaxDamage" class="block text-sm font-medium text-gray-700">ç”»åƒå‡ºåŠ›æ™‚ã®æœ€å¤§è¡¨ç¤ºç‚¹æ•°</label>
                        <input type="number" id="imageMaxDamage" value="10" min="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border" placeholder="ç©ºæ¬„ã§è‡ªå‹•">
                    </div>
                </div>

                <button id="runButton" onclick="handleSimulation()" class="mt-6 w-full py-3 px-4 border border-transparent rounded-md shadow-sm text-lg font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition duration-150 ease-in-out">
                    ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
                </button>
            </div>

            <!-- çµæœè¡¨ç¤ºã‚¨ãƒªã‚¢ (lg:col-span-2) -->
            <div class="lg:col-span-2 p-6 bg-white rounded-xl card-shadow">
                <h2 class="text-xl font-bold mb-4 text-gray-800 border-b pb-2 flex justify-between items-center">
                    çµæœ
                    <button id="imageOutputButton" onclick="generateImage()" class="text-sm py-1 px-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition duration-150 ease-in-out hidden">
                        ç”»åƒå‡ºåŠ›
                    </button>
                </h2>
                <div id="statusMessage" class="mb-4 text-center text-indigo-600 font-semibold hidden">
                    è¨ˆç®—ä¸­ã§ã™...
                </div>
                
                <div id="lethalExpectation" class="mb-5 hidden">
                    <p class="text-sm text-gray-600">ãƒªãƒ¼ã‚µãƒ«æœŸå¾…å€¤ (é€šã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã®å¹³å‡)</p>
                    <p id="expectationValue" class="text-4xl font-extrabold text-indigo-700"></p>
                </div>

                <!-- çµæœã‚°ãƒ©ãƒ•è¡¨ç¤ºé ˜åŸŸ -->
                <div id="resultsOutput" class="space-y-3">
                    <p class="text-gray-500">å®Ÿè¡Œãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚</p>
                </div>

                <div id="summary" class="mt-6 pt-4 border-t border-gray-200">
                    <p id="summaryText" class="text-sm text-gray-600"></p>
                </div>
            </div>
        </main>
        
        <footer class="mt-8 text-center text-sm text-gray-500 p-4">
            <p>ãƒ´ã‚¡ã‚¤ã‚¹ã¯ç¢ºç‡ã§ã¯ãªã„ â€“ PineAme@tcepseredutitta</p>
        </footer>

        <!-- ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ—èª¬æ˜ãƒ¢ãƒ¼ãƒ€ãƒ« -->
        <div id="explanationModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 hidden transition-opacity duration-300 items-center justify-center p-4" onclick="if (event.target === this) closeExplanationModal()">
            <div class="bg-white rounded-xl shadow-2xl max-w-lg w-full p-6 transform transition-all duration-300 scale-95 opacity-0" id="modalContent">
                <div class="flex justify-between items-center border-b pb-3 mb-4">
                    <h3 class="text-xl font-bold text-indigo-700">ã‚¢ã‚¯ã‚·ãƒ§ãƒ³åˆ— å‡¡ä¾‹</h3>
                    <button onclick="closeExplanationModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                <div class="text-gray-700 space-y-3">
                    <p class="font-semibold text-gray-800">å…¥åŠ›å½¢å¼: ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã§ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¨˜è¿° (ä¾‹: 3k,4,3c,2m,1b)</p>
                    <p class="text-sm">ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¼´ã‚ãªã„ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ (k, b) ã¯ã€ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†ã‚ˆã‚Šå…ˆã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚</p>
                    <ul class="list-disc list-inside space-y-2 pl-4">
                        <li><strong class="font-mono text-indigo-600">N</strong>: Nãƒ€ãƒ¡ãƒ¼ã‚¸ (Nç‚¹ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å®Ÿè¡Œ)</li>
                        <li><strong class="font-mono text-indigo-600">Nk</strong>: å…‰æ™¯ (Næšã®éCXã‚’æ§ãˆå®¤ã«è¿½åŠ ã—ã€å±±æœ­ã®ä¸Šã‹ã‚‰Næšã‚’ã‚²ãƒ¼ãƒ ã‹ã‚‰é™¤å¤–ã™ã‚‹)</li>
                        <li><strong class="font-mono text-indigo-600">Nb</strong>: Næšé€†åœ§ç¸® (Næšã®CXã§ãªã„ã‚«ãƒ¼ãƒ‰ã‚’å±±æœ­ã«åŠ ãˆã¦ã‚·ãƒ£ãƒƒãƒ•ãƒ«)</li>
                        <li><strong class="font-mono text-indigo-600">Nu</strong>: 1æšãƒˆãƒƒãƒ—ç››ã‚Š + Nãƒ€ãƒ¡ãƒ¼ã‚¸ (CXã§ãªã„ã‚«ãƒ¼ãƒ‰ã‚’ãƒˆãƒƒãƒ—ã«è¿½åŠ å¾Œã€Nãƒ€ãƒ¡ãƒ¼ã‚¸)</li>
                        <li><strong class="font-mono text-indigo-600">Nm</strong>: ãƒ¢ã‚« + Nãƒ€ãƒ¡ãƒ¼ã‚¸ (ãƒˆãƒƒãƒ—2æšæ“ä½œå¾Œã€Nãƒ€ãƒ¡ãƒ¼ã‚¸)</li>
                        <li><strong class="font-mono text-indigo-600">Nc</strong>: ç›´å‰ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«æ™‚ Nãƒ€ãƒ¡ãƒ¼ã‚¸ (ç›´å‰ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¦ã„ãŸå ´åˆã®ã¿Nãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å®Ÿè¡Œ)</li>
                        <li><strong class="font-mono text-indigo-600">Ns</strong>: å±±æœ­ä¸‹Næšå¢“åœ°é€ã‚ŠCXãƒ€ãƒ¡ãƒ¼ã‚¸ (å±±æœ­ä¸‹Næšã‚’æ§ãˆå®¤ã«é€ã‚Šã€ãã®ä¸­ã®CXæšæ•°ãƒ€ãƒ¡ãƒ¼ã‚¸)</li>
                        <!-- â–¼â–¼â–¼ æ–°è¦è¿½åŠ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ â–¼â–¼â–¼ -->
                        <li><strong class="font-mono text-red-600">Nsp</strong>: çœŸç´ã‚¹ãƒ‘ãƒŠ (Ns, 3ã‚’å®Ÿæ–½ã€‚ã©ã¡ã‚‰ã‹ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ™‚ã€Ns, 3ã‚’å†åº¦å®Ÿæ–½)</li>
                        <!-- â–²â–²â–² æ–°è¦è¿½åŠ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ â–²â–²â–² -->
                    </ul>
                </div>
                <button onclick="closeExplanationModal()" class="mt-6 w-full py-2 bg-indigo-600 text-white rounded-lg shadow hover:bg-indigo-700 transition">é–‰ã˜ã‚‹</button>
            </div>
        </div>
        
        <!-- ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ« -->
        <div id="imagePreviewModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 hidden transition-opacity duration-300 items-center justify-center p-4" onclick="if (event.target === this) closeImagePreviewModal()">
            <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full p-6 transform transition-all duration-300 scale-95 opacity-0" id="imagePreviewContent" style="max-height: 90vh; display: flex; flex-direction: column;">
                <div class="flex justify-between items-center border-b pb-3 mb-4 flex-shrink-0">
                    <h3 class="text-xl font-bold text-indigo-700">ç”»åƒç¢ºèª</h3>
                    <button onclick="closeImagePreviewModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                <div class="flex-grow overflow-y-auto mb-4 border rounded-lg p-2 bg-gray-50">
                    <img id="previewImage" src="" alt="ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœç”»åƒ" class="w-full h-auto object-contain">
                </div>
                <div class="flex justify-end gap-3 flex-shrink-0">
                    <button onclick="closeImagePreviewModal()" class="py-2 px-4 bg-gray-300 text-gray-800 rounded-lg shadow hover:bg-gray-400 transition">é–‰ã˜ã‚‹</button>
                    <button id="downloadButton" class="py-2 px-4 bg-indigo-600 text-white rounded-lg shadow hover:bg-indigo-700 transition">ç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
                </div>
            </div>
        </div>

        <!-- ç”»åƒå‡ºåŠ›ç”¨ã®ä¸€æ™‚ã‚³ãƒ³ãƒ†ãƒŠ (éè¡¨ç¤º) -->
        <div id="imageSourceContainer" class="absolute top-0 left-0" style="z-index: -10; opacity: 0; pointer-events: none; transform: translateX(-1000px);">
            <div id="imageSource" style="width: 500px; font-family: 'Inter', sans-serif;">
                <!-- Content will be injected here for image generation -->
            </div>
        </div>

    </div>

    <script>
        // TypeScriptã®å‹ãƒ’ãƒ³ãƒˆã‚’æ¨¡å€£
        /** @typedef {'CX' | 'UnCX'} Card */
        /** @typedef {Object.<number, number>} DamageCounts */
        /** @typedef {Object.<number, number>} CumulativeProbabilities */
        /** @typedef {{
             amount: number, 
             isDamage: boolean, 
             hasMoka: boolean, 
             hasUnCXTop: boolean,
             hasBuryShuffle: boolean,
             hasConditionalCancel: boolean,
             hasBottomScrape: boolean,
             hasKoukei: boolean,
             hasMakotoSpanner: boolean // â–¼â–¼â–¼ æ–°è¦è¿½åŠ : çœŸç´ã‚¹ãƒ‘ãƒŠ â–¼â–¼â–¼
           }} DamageItem 
        */

        const Card = {
            CX: 'CX',
            UnCX: 'UnCX'
        };
        
        let lastProbabilities = null;
        let lastSettings = null;
        let lastExpectation = 0;

        // ====================================================================
        // ğŸ› ï¸ è¨­å®šä¿å­˜ãƒ»èª­ã¿è¾¼ã¿é–¢æ•°
        // ====================================================================

        function saveSettings() {
            localStorage.setItem('ws_deckSize', document.getElementById('deckSize').value);
            localStorage.setItem('ws_cxCount', document.getElementById('cxCount').value);
            // â–¼â–¼â–¼ æ§ãˆå®¤ã®æƒ…å ±ã‚’ä¿å­˜ â–¼â–¼â–¼
            localStorage.setItem('ws_discardCxCount', document.getElementById('discardCxCount').value);
            localStorage.setItem('ws_discardUnCxCount', document.getElementById('discardUnCxCount').value);
            // â–²â–²â–²
            localStorage.setItem('ws_damages', document.getElementById('damages').value);
            localStorage.setItem('ws_simulations', document.getElementById('simulations').value);
            localStorage.setItem('ws_refreshToggle', document.getElementById('refreshToggle').checked);
            localStorage.setItem('ws_imageMaxDamage', document.getElementById('imageMaxDamage').value); 
        }

        function loadSettings() {
            const deckSizeInput = document.getElementById('deckSize');
            const cxCountInput = document.getElementById('cxCount');
            // â–¼â–¼â–¼ æ§ãˆå®¤ã®æƒ…å ±ã‚’èª­ã¿è¾¼ã¿ â–¼â–¼â–¼
            const discardCxCountInput = document.getElementById('discardCxCount');
            const discardUnCxCountInput = document.getElementById('discardUnCxCount');
            // â–²â–²â–²
            const damagesInput = document.getElementById('damages');
            const simulationsInput = document.getElementById('simulations');
            const refreshToggleInput = document.getElementById('refreshToggle');
            const imageMaxDamageInput = document.getElementById('imageMaxDamage'); 

            deckSizeInput.value = localStorage.getItem('ws_deckSize') || deckSizeInput.value;
            cxCountInput.value = localStorage.getItem('ws_cxCount') || cxCountInput.value;
            // â–¼â–¼â–¼ æ§ãˆå®¤ã®æƒ…å ±ã‚’èª­ã¿è¾¼ã¿ â–¼â–¼â–¼
            discardCxCountInput.value = localStorage.getItem('ws_discardCxCount') || discardCxCountInput.value;
            discardUnCxCountInput.value = localStorage.getItem('ws_discardUnCxCount') || discardUnCxCountInput.value;
            // â–²â–²â–²
            damagesInput.value = localStorage.getItem('ws_damages') || "1,3,3,3";
            simulationsInput.value = localStorage.getItem('ws_simulations') || simulationsInput.value;
            imageMaxDamageInput.value = localStorage.getItem('ws_imageMaxDamage') || imageMaxDamageInput.value; 
            
            const refreshToggleValue = localStorage.getItem('ws_refreshToggle');
            if (refreshToggleValue !== null) {
                refreshToggleInput.checked = refreshToggleValue === 'true';
            }
        }

        // ====================================================================
        // ãƒ´ã‚¡ã‚¤ã‚¹ã‚·ãƒ¥ãƒ´ã‚¡ãƒ«ãƒ„ ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ ã‚¯ãƒ©ã‚¹ 
        // ====================================================================

        class WeissDamageSimulator {
            constructor() {
                this.rng = Math; 
                /** @type {Card[]} */
                this.discardPile = [];
            }

            _shuffle(deck) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
            }

            _refresh(deck, totalPassedDamage, applyRefreshDamage) {
                const addedDamage = applyRefreshDamage ? 1 : 0;
                deck.push(...this.discardPile);
                this.discardPile = [];
                this._shuffle(deck);
                return [addedDamage, deck];
            }
            
            /**
             * ãƒ¢ã‚«èƒ½åŠ›å‡¦ç†: å±±æœ­ä¸Š2æšã¾ã§è¦‹ã¦CXã‚’æ§ãˆå®¤ã«ç½®ãã€æ®‹ã‚Šã‚’å±±æœ­ãƒˆãƒƒãƒ—ã«æˆ»ã™ã€‚
             */
            _processMokaEffect(currentDeck, totalPassedDamage, applyRefreshDamage) {
                let refreshDamage = 0;
                let newDeck = currentDeck;

                if (newDeck.length === 0) return [0, newDeck];

                /** @type {Card[]} */
                const revealedCards = [];
                // 1. å±±æœ­ã®ä¸Šã‹ã‚‰2æšã¾ã§è¦‹ã‚‹ï¼ˆå±±æœ­ã‹ã‚‰å–ã‚Šé™¤ãï¼‰
                for (let i = 0; i < 2; i++) {
                    if (newDeck.length === 0) {
                        // ãƒ¢ã‚«ã®é€”ä¸­ã§ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
                        const [addedDamage, refreshedDeck] = this._refresh(newDeck, totalPassedDamage + refreshDamage, applyRefreshDamage);
                        refreshDamage += addedDamage;
                        totalPassedDamage += addedDamage; // ç´¯ç©ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚‚æ›´æ–°
                        newDeck = refreshedDeck;
                        
                        if (newDeck.length === 0) break; // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å¾Œã‚‚ç©ºãªã‚‰çµ‚äº†
                    }
                    // shift()ã¯é…åˆ—ã‹ã‚‰è¦ç´ ã‚’å‰Šé™¤ã—ã¦è¿”ã™
                    const drawnCard = newDeck.shift();
                    if (drawnCard) {
                        revealedCards.push(drawnCard);
                    }
                }
                
                /** @type {Card[]} */
                const cxCards = [];
                /** @type {Card[]} */
                const otherCards = [];

                // 2. CXã¨ãã®ä»–ã®ã‚«ãƒ¼ãƒ‰ã‚’åˆ†é¡
                for (const card of revealedCards) {
                    if (card === Card.CX && cxCards.length < 2) {
                        cxCards.push(card); 
                    } else {
                        otherCards.push(card); 
                    }
                }

                // 3. CXã‚’æ§ãˆå®¤ã«ç½®ã
                this.discardPile.push(...cxCards);

                // 4. æ®‹ã‚Šã®ã‚«ãƒ¼ãƒ‰ã‚’å±±æœ­ã®ä¸Šã«å¥½ããªé †ç•ªã§ç½®ã
                this._shuffle(otherCards); 
                newDeck.unshift(...otherCards);

                return [refreshDamage, newDeck];
            }

            _processUnCXTopEffect(currentDeck) {
                currentDeck.unshift(Card.UnCX);
            }

            _processBuryShuffleEffect(currentDeck, count) {
                if (count <= 0) return;
                for (let i = 0; i < count; i++) {
                    currentDeck.push(Card.UnCX);
                }
                this._shuffle(currentDeck);
            }
            
            /**
             * (Ns) å±±æœ­ä¸‹Næšå¢“åœ°é€ã‚ŠCXãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
             * @returns {number} - ç™ºç”Ÿã—ãŸCXãƒ€ãƒ¡ãƒ¼ã‚¸
             */
            _processBottomScrapeEffect(currentDeck, amountN) {
                let cxCount = 0;
                for (let i = 0; i < amountN && currentDeck.length > 0; i++) {
                    const card = currentDeck.pop();
                    if (card === Card.CX) {
                        cxCount++;
                    }
                    if (card) {
                        this.discardPile.push(card);
                    }
                }
                return cxCount;
            }

            /**
             * (Nk) å…‰æ™¯å‡¦ç†
             */
            _processKoukeiEffect(currentDeck, amountN, totalPassedDamage, applyRefreshDamage) {
                let refreshDamage = 0;
                let newDeck = currentDeck;

                // åŠ¹æœ1: Næšã®éCXã‚«ãƒ¼ãƒ‰ã‚’æ§ãˆå®¤ã«è¿½åŠ ã™ã‚‹
                for (let i = 0; i < amountN; i++) {
                    this.discardPile.push(Card.UnCX);
                }

                // åŠ¹æœ2: å±±æœ­ã®ä¸Šã‹ã‚‰Næšã‚’ã‚²ãƒ¼ãƒ ã‹ã‚‰é™¤å¤–ã™ã‚‹ï¼ˆé™¤å¤–ï¼‰
                for (let i = 0; i < amountN; i++) {
                    // å±±æœ­ãŒç©ºã«ãªã£ãŸã‚‰ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
                    if (newDeck.length === 0) {
                        const [addedDamage, refreshedDeck] = this._refresh(newDeck, totalPassedDamage + refreshDamage, applyRefreshDamage);
                        refreshDamage += addedDamage;
                        totalPassedDamage += addedDamage; // ç´¯ç©ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚‚æ›´æ–°
                        newDeck = refreshedDeck;

                        if (newDeck.length === 0) {
                            break; // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å¾Œã‚‚ç©ºãªã‚‰çµ‚äº†
                        }
                    }
                    
                    // å±±æœ­ã®å…ˆé ­ã‹ã‚‰1æšã‚ãã‚Šã€æ§ãˆå®¤ã«ã¯ç½®ã‹ãšã«ç ´æ£„ï¼ˆé™¤å¤–ï¼‰ã™ã‚‹
                    newDeck.shift(); 
                }
                
                return [refreshDamage, newDeck]; // [è¿½åŠ ãƒ€ãƒ¡ãƒ¼ã‚¸, æ›´æ–°ã•ã‚ŒãŸå±±æœ­]
            }


            /**
             * æ¨™æº–ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç† (ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å‡¦ç†ã‚‚å†…åŒ…)
             * @param {Card[]} currentDeck 
             * @param {number} damageAmount - å®Ÿè¡Œã™ã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ç‚¹æ•°
             * @param {number} totalPassedDamage - ç¾åœ¨ã®ç´¯ç©é€šéãƒ€ãƒ¡ãƒ¼ã‚¸
             * @param {boolean} applyRefreshDamage - ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒ€ãƒ¡ãƒ¼ã‚¸ã®é©ç”¨ãƒ•ãƒ©ã‚°
             * @returns {[number, number, boolean]} - [é€šéãƒ€ãƒ¡ãƒ¼ã‚¸, è¿½åŠ ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒ€ãƒ¡ãƒ¼ã‚¸, ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸã‹]
             */
            _processDamage(currentDeck, damageAmount, totalPassedDamage, applyRefreshDamage) {
                let passedDamage = 0;
                let refreshDamage = 0;
                let isCancelled = false;
                
                if (damageAmount <= 0) {
                     return [0, 0, false];
                }

                for (let i = 0; i < damageAmount; i++) {
                    // ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†ä¸­ã®ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
                    if (currentDeck.length === 0) {
                        const [addedDamage, newDeck] = this._refresh(currentDeck, totalPassedDamage, applyRefreshDamage);
                        refreshDamage += addedDamage;
                        totalPassedDamage += addedDamage;
                        currentDeck = newDeck;
                        if (currentDeck.length === 0) {
                            break;
                        }
                    }

                    const drawnCard = currentDeck.shift(); 

                    if (drawnCard === Card.CX) {
                        isCancelled = true;
                        this.discardPile.push(drawnCard);
                        passedDamage = 0;
                        break; 
                    }

                    if (drawnCard) {
                        passedDamage++;
                        this.discardPile.push(drawnCard);
                    }
                }
                
                // ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒ1ç‚¹ä»¥ä¸Šã§ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸã‹ (ä¾‹: 3ç‚¹ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãªã‚‰ true, 0ç‚¹ãƒ€ãƒ¡ãƒ¼ã‚¸ãªã‚‰ false)
                const finalCancellationStatus = (damageAmount > 0 && passedDamage === 0);

                return [passedDamage, refreshDamage, finalCancellationStatus];
            }

            /**
             * ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã€ãƒ€ãƒ¡ãƒ¼ã‚¸ç‚¹æ•°ã”ã¨ã®ç´¯ç©ç¢ºç‡ã‚’è¿”ã™ã€‚
             * @param {number} initialDeckSize 
             * @param {number} cxCount 
             * @param {number} initialDiscardCx 
             * @param {number} initialDiscardUnCx 
             * @param {DamageItem[]} actions 
             * @param {number} simulations 
             * @param {boolean} applyRefreshDamage 
             * @returns {CumulativeProbabilities}
             */
            runSimulation(initialDeckSize, cxCount, initialDiscardCx, initialDiscardUnCx, actions, simulations, applyRefreshDamage) {
                /** @type {DamageCounts} */
                const damageCounts = {};
                const unCxCount = initialDeckSize - cxCount;
                
                const maxPossibleDamage = actions
                    .filter(a => a.isDamage || a.hasMakotoSpanner) // Spannerã‚‚è€ƒæ…®
                    .reduce((sum, d) => {
                        if (d.hasMakotoSpanner) return sum + d.amount * 2 + 3 * 2; // æœ€ä½2å›ç™ºå‹•ã¨ã—ã¦æ¦‚ç®—
                        return sum + d.amount;
                    }, 0) + (applyRefreshDamage ? 10 : 0); 

                for (let sim = 0; sim < simulations; sim++) {
                    // 1. æ§ãˆå®¤ã®åˆæœŸåŒ– 
                    this.discardPile = Array(initialDiscardCx).fill(Card.CX).concat(Array(initialDiscardUnCx).fill(Card.UnCX));
                    
                    // 2. åˆæœŸå±±æœ­ã®ä½œæˆã¨ã‚·ãƒ£ãƒƒãƒ•ãƒ«
                    /** @type {Card[]} */
                    let deck = Array(cxCount).fill(Card.CX).concat(Array(unCxCount).fill(Card.UnCX));
                    this._shuffle(deck);

                    // 3. ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ã®å®Ÿè¡Œ
                    let totalPassedDamage = 0;
                    let lastDamageCancelled = false; // ç›´å‰ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸã‹
                    
                    let currentDeck = deck; 

                    for (const action of actions) {
                        
                        let currentActionAmount = action.amount;
                        let damageCancelled = false; // ç¾åœ¨ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãŒç™ºç”Ÿã—ãŸã‹
                        
                        // 3a. (Nb) å±±æœ­ã«ã‚«ãƒ¼ãƒ‰ã‚’åŠ ãˆã¦ã‚·ãƒ£ãƒƒãƒ•ãƒ«
                        if (action.hasBuryShuffle) {
                            this._processBuryShuffleEffect(currentDeck, currentActionAmount);
                            continue; 
                        }
                        
                        // 3b. (Nk) å…‰æ™¯
                        if (action.hasKoukei) {
                            const [addedDamage, newDeck] = this._processKoukeiEffect(currentDeck, currentActionAmount, totalPassedDamage, applyRefreshDamage);
                            totalPassedDamage += addedDamage;
                            currentDeck = newDeck;
                            continue; 
                        }
                        
                        // 3c. (Nsp) çœŸç´ã‚¹ãƒ‘ãƒŠ
                        if (action.hasMakotoSpanner) {
                            let repeat = true;
                            let playCount = 0;
                            while(repeat && playCount < 2) {
                                playCount = playCount + 1;
                                repeat = false; // åŸºæœ¬ã¯1å›ã§çµ‚äº†
                                let currentRepeatCancelled = false;
                                
                                // Nspã®Nsãƒ‘ãƒ¼ãƒˆ: å±±æœ­ä¸‹Næšå¢“åœ°é€ã‚ŠCXãƒ€ãƒ¡ãƒ¼ã‚¸
                                let xDamage = 0;
                                // Nsã®å‰ã«å±±æœ­ãŒ0æšãªã‚‰ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
                                if (currentDeck.length === 0) {
                                    const [addedDamage, newDeck] = this._refresh(currentDeck, totalPassedDamage, applyRefreshDamage);
                                    totalPassedDamage += addedDamage;
                                    currentDeck = newDeck;
                                }
                                
                                if (currentDeck.length > 0) {
                                    xDamage = this._processBottomScrapeEffect(currentDeck, currentActionAmount);
                                }
                                
                                // Nsã«ã‚ˆã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç† (å±±æœ­ã‚’æ¶ˆè²»ã—ãªã„CXãƒ€ãƒ¡ãƒ¼ã‚¸)
                                if (xDamage > 0) {
                                    const [passedDmg, refreshAdd, isCancelled] = this._processDamage(currentDeck, xDamage, totalPassedDamage, applyRefreshDamage);
                                    totalPassedDamage += passedDmg;
                                    totalPassedDamage += refreshAdd; 
                                    if (isCancelled) {
                                        currentRepeatCancelled = true;
                                    }
                                }

                                // Nspã®3ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒ‘ãƒ¼ãƒˆ
                                const regularDamage = 3; 
                                const [passedDmg, refreshAdd, isCancelled] = this._processDamage(currentDeck, regularDamage, totalPassedDamage, applyRefreshDamage);
                                
                                totalPassedDamage += passedDmg;
                                totalPassedDamage += refreshAdd; 
                                
                                if (isCancelled) {
                                    currentRepeatCancelled = true;
                                }
                                
                                // 1. Nsã¾ãŸã¯3ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸå ´åˆã€å†åº¦Ns, 3ã‚’å®Ÿè¡Œ
                                if (currentRepeatCancelled) {
                                    repeat = true;
                                }
                            }
                            // Nspã¯è¤‡æ•°ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å«ã‚€ãŸã‚ã€lastDamageCancelledã®æ›´æ–°ã¯å€‹ã€…ã®å‡¦ç†ã§ã¯ãªãã€ãƒ«ãƒ¼ãƒ—å†…ã§å®Œçµã•ã›ã‚‹ã€‚
                            lastDamageCancelled = false; // Nspã®çµæœã¯æ¬¡ã®Ncã«å½±éŸ¿ã‚’ä¸ãˆãªã„ã¨ä»®å®šã™ã‚‹
                            continue;
                        }

                        // 3d. (Ns) å±±æœ­ä¸‹Næšå¢“åœ°é€ã‚ŠCXãƒ€ãƒ¡ãƒ¼ã‚¸ (Nspã§ãªã‘ã‚Œã°ã“ã¡ã‚‰)
                        if (action.hasBottomScrape) {
                            let xDamage = 0;
                            // Nsã®å‰ã«å±±æœ­ãŒ0æšãªã‚‰ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
                            if (currentDeck.length === 0) {
                                const [addedDamage, newDeck] = this._refresh(currentDeck, totalPassedDamage, applyRefreshDamage);
                                totalPassedDamage += addedDamage;
                                currentDeck = newDeck;
                            }
                            
                            if (currentDeck.length > 0) {
                                xDamage = this._processBottomScrapeEffect(currentDeck, currentActionAmount);
                            }
                            currentActionAmount = xDamage; 
                            // Nsã¯å±±æœ­ã‚’å‰Šã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã§ã¯ãªã„ãŸã‚ã€Ncã¨ã®é€£å‹•ã‚’è€ƒæ…®ã—ãªã„ã€‚
                        }

                        // 3e. (Nc) æ¡ä»¶ä»˜ããƒ€ãƒ¡ãƒ¼ã‚¸
                        if (action.hasConditionalCancel) {
                            if (!lastDamageCancelled) {
                                lastDamageCancelled = false; // NcãŒä¸ç™ºã ã£ãŸå ´åˆã€æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«å½±éŸ¿ã—ãªã„
                                continue;
                            }
                            // NcãŒç™ºå‹•ã—ãŸå ´åˆã€é€šå¸¸ãƒ€ãƒ¡ãƒ¼ã‚¸ã¨ã—ã¦æ‰±ã†
                        }
                        
                        // 3f. ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç† (N, Nm, Nu, Ns, Nc)
                        
                        // ç‰¹æ®Šèƒ½åŠ› (u, m) ã‚’é©ç”¨
                        if (currentDeck.length > 0) { 
                            if (action.hasUnCXTop) {
                                this._processUnCXTopEffect(currentDeck);
                            }
                        }
                        
                        if (action.hasMoka) {
                            const [addedDamage, newDeck] = this._processMokaEffect(currentDeck, totalPassedDamage, applyRefreshDamage);
                            totalPassedDamage += addedDamage;
                            currentDeck = newDeck;
                        }
                        
                        // ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†å‰ã®ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
                        while (currentDeck.length === 0 && currentActionAmount > 0) {
                            const [addedDamage, newDeck] = this._refresh(currentDeck, totalPassedDamage, applyRefreshDamage);
                            totalPassedDamage += addedDamage;
                            currentDeck = newDeck;
                            if (currentDeck.length === 0) break;
                        }
                        
                        // ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†ã‚’å®Ÿè¡Œ
                        let passedDamage = 0;
                        let refreshAdded = 0;
                        
                        const results = this._processDamage(currentDeck, currentActionAmount, totalPassedDamage, applyRefreshDamage);
                        passedDamage = results[0];
                        refreshAdded = results[1];
                        damageCancelled = results[2]; // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—

                        totalPassedDamage += passedDamage;
                        totalPassedDamage += refreshAdded; 
                        
                        lastDamageCancelled = damageCancelled; // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°
                    }

                    // 4. çµæœã®é›†è¨ˆ
                    damageCounts[totalPassedDamage] = (damageCounts[totalPassedDamage] || 0) + 1;
                }

                // 5. ç´¯ç©ç¢ºç‡ã®è¨ˆç®— (çœç•¥ã€æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ã‚’ä½¿ç”¨)
                /** @type {CumulativeProbabilities} */
                const cumulativeProbabilities = {};
                
                let cumulativeCount = 0;
                const maxDamageObserved = Object.keys(damageCounts).length > 0 
                    ? Math.max(...Object.keys(damageCounts).map(Number)) 
                    : 0;
                
                const loopEnd = Math.max(maxDamageObserved, maxPossibleDamage, 1);

                for (let d = loopEnd; d >= 1; d--) {
                    cumulativeCount += damageCounts[d] || 0;
                    cumulativeProbabilities[d] = cumulativeCount / simulations;
                }

                return cumulativeProbabilities;
            }
        }

        // ====================================================================
        // ğŸš€ UIæ“ä½œã¨å®Ÿè¡Œé–¢æ•° (çœç•¥ã€å¤‰æ›´ãªã—)
        // ====================================================================

        const simulator = new WeissDamageSimulator();
        const resultsOutput = document.getElementById('resultsOutput');
        const statusMessage = document.getElementById('statusMessage');
        const runButton = document.getElementById('runButton');
        const summaryText = document.getElementById('summaryText');
        const expectationDiv = document.getElementById('lethalExpectation');
        const expectationValueText = document.getElementById('expectationValue');
        
        function showCustomMessage(message, type = 'info') {
            const alertDiv = document.createElement('div');
            const colorMap = {
                'red': { bg: '#f8d7da', text: '#721c24' },
                'info': { bg: '#d4edda', text: '#155724' }
            };
            const colors = colorMap[type] || colorMap['info'];
            alertDiv.style.cssText = `
                position: fixed; top: 20px; right: 20px; 
                padding: 10px 20px; border-radius: 8px; 
                background-color: ${colors.bg}; 
                color: ${colors.text}; 
                box-shadow: 0 4px 6px rgba(0,0,0,0.1); 
                z-index: 1000;
                opacity: 0;
                transition: opacity 0.5s ease-in-out;
            `;
            alertDiv.textContent = message;
            document.body.appendChild(alertDiv);
            setTimeout(() => { alertDiv.style.opacity = 1; }, 10);
            setTimeout(() => {
                alertDiv.style.opacity = 0;
                setTimeout(() => document.body.removeChild(alertDiv), 500);
            }, 4000);
        }

        // ----------------------------------------------------
        // ğŸ–¼ï¸ ãƒ¢ãƒ¼ãƒ€ãƒ«åˆ¶å¾¡ (ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼, èª¬æ˜)
        // ----------------------------------------------------
        
        function showImagePreviewModal(base64Image) {
            const modal = document.getElementById('imagePreviewModal');
            const content = document.getElementById('imagePreviewContent');
            const previewImage = document.getElementById('previewImage');
            const downloadButton = document.getElementById('downloadButton');
            
            previewImage.src = base64Image;
            downloadButton.onclick = () => downloadImage(base64Image); 

            modal.classList.remove('hidden');
            modal.classList.add('flex', 'modal-enter'); 
            
            setTimeout(() => {
                modal.classList.add('modal-enter-active');
                content.classList.add('modal-content-enter-active');
                content.classList.remove('scale-95', 'opacity-0');
            }, 10);
        }

        function closeImagePreviewModal() {
            const modal = document.getElementById('imagePreviewModal');
            const content = document.getElementById('imagePreviewContent');
            modal.classList.remove('modal-enter-active');
            modal.classList.add('modal-leave-active');
            content.classList.remove('modal-content-enter-active');
            content.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
                modal.classList.remove('flex', 'modal-leave-active', 'modal-enter');
            }, 300); 
        }

        function downloadImage(base64Image) {
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            link.download = `WS_Lethal_Calc_Result_${timestamp}.png`;
            link.href = base64Image;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showCustomMessage("ç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸã€‚", 'info');
            closeImagePreviewModal();
        }

        function showExplanationModal() {
            const modal = document.getElementById('explanationModal');
            const content = document.getElementById('modalContent');
            modal.classList.remove('hidden');
            modal.classList.add('flex', 'modal-enter'); 
            setTimeout(() => {
                modal.classList.add('modal-enter-active');
                content.classList.add('modal-content-enter-active');
                content.classList.remove('scale-95', 'opacity-0');
            }, 10);
        }

        function closeExplanationModal() {
            const modal = document.getElementById('explanationModal');
            const content = document.getElementById('modalContent');
            modal.classList.remove('modal-enter-active');
            modal.classList.add('modal-leave-active');
            content.classList.remove('modal-content-enter-active');
            content.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
                modal.classList.remove('flex', 'modal-leave-active', 'modal-enter');
            }, 300);
        }
        
        /**
         * çµæœã®ç¢ºç‡ãƒªã‚¹ãƒˆã‚’æ•´å½¢ã—ã¦è¡¨ç¤ºã™ã‚‹
         */
        function displayResults(probabilities, settings, timeTaken) {
            const { simulations, initialDeckSize, cxCount, initialDiscardCx, initialDiscardUnCx, actions } = settings;
            
            resultsOutput.innerHTML = '';
            
            const maxDamageResult = Math.max(...Object.keys(probabilities).map(Number));
            const results = [];
            
            const expectation = Object.values(probabilities).reduce((sum, prob) => sum + prob, 0);
            expectationDiv.classList.remove('hidden');
            expectationValueText.textContent = `${expectation.toFixed(2)}ç‚¹`;

            // è¡¨ç¤ºç”¨ã®ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ—æ–‡å­—åˆ—ã‚’ä½œæˆ 
            const damagesString = actions.map(d => {
                if (d.hasBuryShuffle) return `${d.amount}b`;
                if (d.hasBottomScrape) return `${d.amount}s`;
                if (d.hasKoukei) return `${d.amount}k`; 
                if (d.hasMakotoSpanner) return `${d.amount}sp`; // â–¼â–¼â–¼ Nspã‚’è¿½åŠ  â–¼â–¼â–¼
                return `${d.amount}${d.hasMoka ? 'm' : ''}${d.hasUnCXTop ? 'u' : ''}${d.hasConditionalCancel ? 'c' : ''}`;
            }).join(', ');
            
            // ç”»åƒå‡ºåŠ›ç”¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
            lastProbabilities = probabilities;
            lastSettings = { ...settings, damagesString }; // æ§ãˆå®¤ã®æƒ…å ±ã‚‚å«ã‚€
            lastExpectation = expectation;
            document.getElementById('imageOutputButton').classList.remove('hidden');
            
            updateImageSource(probabilities, lastSettings, lastExpectation);

            for (let d = 1; d <= maxDamageResult; d++) {
                const prob = probabilities[d] || 0.0;
                const percentage = (prob * 100).toFixed(2);
                const barWidth = Math.max(parseFloat(percentage), 1);
                
                let barColor;
                if (prob >= 0.8) barColor = 'bg-green-600';
                else if (prob >= 0.5) barColor = 'bg-yellow-500';
                else if (prob >= 0.3) barColor = 'bg-orange-400';
                else barColor = 'bg-red-500';

                results.push(`
                    <div class="flex items-center space-x-2">
                        <span class="font-mono text-sm text-gray-500 flex-shrink-0 whitespace-nowrap w-16">${d}ç‚¹ä»¥ä¸Š}</span>
                        <div class="flex-grow bg-gray-200 rounded-full h-6 relative overflow-hidden">
                            <div class="${barColor} h-full rounded-full transition-all duration-300 ease-out" style="width: ${barWidth}%;"></div>
                             <span class="absolute right-0 top-0 bottom-0 pr-2 flex items-center text-xs font-bold text-gray-800">${percentage}%</span>
                        </div>
                    </div>
                `);
            }

            resultsOutput.innerHTML = results.length > 0 ? results.join('') : '<p class="text-gray-500">ãƒªãƒ¼ã‚µãƒ«ï¼ˆ1ç‚¹ä»¥ä¸Šã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰ãŒç™ºç”Ÿã—ã¾ã›ã‚“ã§ã—ãŸã€‚</p>';

            // ã‚µãƒãƒªãƒ¼ã«æ§ãˆå®¤æƒ…å ±ã‚’è¿½åŠ 
            const initialDiscardTotal = initialDiscardCx + initialDiscardUnCx;
            summaryText.textContent = `
                è¨­å®šï¼šå±±æœ­${initialDeckSize}æš (CX${cxCount}æš), æ§ãˆå®¤${initialDiscardTotal}æš (CX${initialDiscardCx}æš), ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ ${damagesString}ã€‚
                ${simulations.toLocaleString()}å›ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ ${(timeTaken / 1000).toFixed(3)} ç§’ã§å®Ÿè¡Œã—ã¾ã—ãŸã€‚
            `;
        }


        /**
         * ç”»åƒå‡ºåŠ›ç”¨ã®éè¡¨ç¤ºã‚³ãƒ³ãƒ†ãƒŠã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æ›´æ–°ã™ã‚‹
         */
        function updateImageSource(probabilities, settings, expectation) {
            // (â–¼â–¼â–¼ æ§ãˆå®¤æƒ…å ±ã‚’è¨­å®šã‹ã‚‰å–å¾— â–¼â–¼â–¼)
            const { initialDeckSize, cxCount, initialDiscardCx, initialDiscardUnCx, damagesString } = settings;
            const imageSource = document.getElementById('imageSource');
            const maxDamageResult = Math.max(...Object.keys(probabilities).map(Number));
            let contentHtml = '';
            
            const initialDiscardTotal = initialDiscardCx + initialDiscardUnCx;

            contentHtml += `
                <div style="font-family: 'Inter', sans-serif; padding: 20px; border: 1px solid #e5e7eb; border-radius: 8px; background-color: #ffffff; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                    <h3 style="font-size: 1.5rem; font-weight: 800; color: #1f2937; margin-bottom: 1rem; border-bottom: 2px solid #e5e7eb; padding-bottom: 8px;">
                        WSãƒªãƒ¼ã‚µãƒ«è¨ˆç®—æ©Ÿ çµæœ
                    </h3>
                    <div style="font-size: 0.9rem; line-height: 1.5; color: #374151; margin-bottom: 1.5rem;">
                        <!-- (â–¼â–¼â–¼ ç”»åƒã«æ§ãˆå®¤æƒ…å ±ã‚’è¿½åŠ  â–¼â–¼â–¼) -->
                        <p style="margin-bottom: 4px; font-weight: 600; color: #4b5563;">å±±æœ­ï¼š${initialDeckSize}æš (CX ${cxCount}æš)</p>
                        <p style="margin-bottom: 4px; font-weight: 600; color: #4b5563;">æ§ãˆå®¤ï¼š${initialDiscardTotal}æš (CX ${initialDiscardCx}æš)</p>
                        <!-- (â–²â–²â–²) -->
                        <p style="font-weight: 600; color: #4b5563; word-break: break-all;">ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼š${damagesString}</p>
                    </div>
                    
                    <div style="margin-bottom: 1.5rem;">
                        <p style="font-size: 0.8rem; color: #4b5563;">ãƒªãƒ¼ã‚µãƒ«æœŸå¾…å€¤ (é€šã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã®å¹³å‡)</p>
                        <p style="font-size: 2.2rem; font-weight: 900; color: #4338ca;">${expectation.toFixed(2)}ç‚¹</p>
                    </div>

                    <div style="font-size: 1rem; line-height: 1.5; color: #374151; display: flex; flex-direction: column; gap: 8px;">
            `;
            
            const imageMaxDamage = parseInt(document.getElementById('imageMaxDamage').value) || 0;
            const loopLimit = imageMaxDamage > 0 ? imageMaxDamage : maxDamageResult;

            let displayedCount = 0;
            for (let d = 1; d <= loopLimit; d++) {
                const prob = probabilities[d] || 0.0;
                const percentage = (prob * 100);

                if (imageMaxDamage === 0 && percentage < 0.01) { // 0.01%æœªæº€ã¯éè¡¨ç¤º (1%ã ã¨å³ã—ã™ããŸãŸã‚ç·©å’Œ)
                    continue;
                }
                displayedCount++;

                const percentageString = percentage.toFixed(2);
                const barWidth = Math.max(parseFloat(percentage), 1);
                
                let barColor;
                if (prob >= 0.8) barColor = '#059669';
                else if (prob >= 0.5) barColor = '#f59e0b';
                else if (prob >= 0.3) barColor = '#fb923c';
                else barColor = '#ef4444';

                contentHtml += `
                    <div style="display: flex; align-items: center; gap: 8px; ">
                        <span style="font-size: 14px; color: #6b7280; flex-shrink: 0; white-space: nowrap; width: 64px;">${d}ç‚¹ä»¥ä¸Š</span> 
                        <div style="flex-grow: 1; background-color: #e5e7eb; border-radius: 9999px; height: 24px; position: relative; overflow-hidden;"> 
                            <div style="background-color: ${barColor}; height: 100%; border-radius: 9999px; width: ${barWidth}%;"></div>
                            <span style="position: absolute; right: 0; top: 0; bottom: 0; padding-right: 8px; display: flex; align-items: center; font-size: 12px; font-weight: 700; color: #1f2937;">${percentageString}%</span> 
                        </div>
                    </div>
                `;
            }
            
            if (displayedCount === 0) {
                 contentHtml += `<p style="color: #6b7280;">ãƒªãƒ¼ã‚µãƒ«ï¼ˆ1ç‚¹ä»¥ä¸Šã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰ãŒç™ºç”Ÿã—ã¾ã›ã‚“ã§ã—ãŸã€‚</p>`;
            }

            contentHtml += `</div></div>`;
            imageSource.innerHTML = contentHtml;
        }

        /**
         * ç”»åƒå‡ºåŠ›ãƒœã‚¿ãƒ³ã®å‡¦ç†
         */
        async function generateImage() {
            if (!lastProbabilities || !lastSettings) {
                showCustomMessage("ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã¦ã‹ã‚‰ç”»åƒã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚", 'red');
                return;
            }
            
            updateImageSource(lastProbabilities, lastSettings, lastExpectation);

            const sourceElement = document.getElementById('imageSource');
            
            try {
                const canvas = await html2canvas(sourceElement, {
                    scale: 2,
                    useCORS: true,
                    backgroundColor: '#ffffff'
                });
                const base64Image = canvas.toDataURL("image/png");
                showImagePreviewModal(base64Image);
                
            } catch (error) {
                console.error("ç”»åƒç”Ÿæˆã‚¨ãƒ©ãƒ¼:", error);
                showCustomMessage("ç”»åƒã®ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚", "red"); 
            }
        }


        /**
         * å…¥åŠ›ã‚’å–å¾—ã—ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã€çµæœã‚’è¡¨ç¤ºã™ã‚‹
         */
        async function handleSimulation() {
            saveSettings();
            
            runButton.disabled = true;
            statusMessage.textContent = 'è¨ˆç®—ä¸­ã§ã™... ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚';
            statusMessage.classList.remove('hidden'); 

            resultsOutput.innerHTML = '';
            summaryText.textContent = '';
            expectationDiv.classList.add('hidden');
            document.getElementById('imageOutputButton').classList.add('hidden');

            try {
                // 3. å…¥åŠ›ã®å–å¾—ã¨æ¤œè¨¼
                const initialDeckSize = parseInt(document.getElementById('deckSize').value);
                const cxCount = parseInt(document.getElementById('cxCount').value);
                // æ§ãˆå®¤æƒ…å ±ã‚’å–å¾—
                const initialDiscardCx = parseInt(document.getElementById('discardCxCount').value);
                const initialDiscardUnCx = parseInt(document.getElementById('discardUnCxCount').value);
                // 
                const simulations = parseInt(document.getElementById('simulations').value);
                const applyRefreshDamage = document.getElementById('refreshToggle').checked;
                
                const damagesInput = document.getElementById('damages').value;
                
                /** @type {DamageItem[]} */
                const actions = damagesInput.split(',').map(s => {
                    const trimmed = s.trim();
                    if (!trimmed) return null; // ç©ºã®æ–‡å­—åˆ—ã¯ç„¡è¦–

                    const hasMoka = trimmed.toLowerCase().includes('m');
                    const hasUnCXTop = trimmed.toLowerCase().includes('u');
                    const hasBuryShuffle = trimmed.toLowerCase().includes('b');
                    const hasConditionalCancel = trimmed.toLowerCase().includes('c');
                    const hasBottomScrape = trimmed.toLowerCase().includes('s');
                    const hasKoukei = trimmed.toLowerCase().includes('k'); 
                    const hasMakotoSpanner = trimmed.toLowerCase().includes('sp'); // â–¼â–¼â–¼ æ–°è¦è¿½åŠ : çœŸç´ã‚¹ãƒ‘ãƒŠ â–¼â–¼â–¼
                    
                    const amountStr = trimmed.replace(/[^0-9]/g, ''); 
                    const amount = parseInt(amountStr);
                    
                    if (isNaN(amount) || amount < 0) return null; // 0ç‚¹ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚‚è¨±å®¹ (0kãªã©)

                    // isDamage ã®åˆ¤å®š
                    const isDamage = !hasBuryShuffle && !hasKoukei && !hasMakotoSpanner; // â–¼â–¼â–¼ Nspã¯å˜ç‹¬ãƒ€ãƒ¡ãƒ¼ã‚¸ã§ã¯ãªã„ â–¼â–¼â–¼

                    return { amount, isDamage, hasMoka, hasUnCXTop, hasBuryShuffle, hasConditionalCancel, hasBottomScrape, hasKoukei, hasMakotoSpanner };
                }).filter(item => item !== null);

                if (initialDeckSize < 0 || cxCount < 0 || initialDiscardCx < 0 || initialDiscardUnCx < 0 || simulations < 1) {
                    throw new Error("å…¥åŠ›å€¤ãŒä¸æ­£ã§ã™ã€‚æšæ•°ã‚„å›æ•°ã¯0ä»¥ä¸Šã®æ•°ã€ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ—ã¯ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
                }
                if (actions.length === 0 && damagesInput !== "") {
                     throw new Error("ã‚¢ã‚¯ã‚·ãƒ§ãƒ³åˆ—ã®æŒ‡å®šãŒä¸æ­£ã§ã™ã€‚å‡¡ä¾‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚ (ä¾‹: 3k, 4, 3c, 2sp)");
                }
                if (cxCount > initialDeckSize) {
                    throw new Error("å±±æœ­ã®CXæšæ•°ãŒåˆæœŸå±±æœ­æšæ•°ã‚’è¶…ãˆã¦ã„ã¾ã™ã€‚");
                }
                // ãƒ‡ãƒƒã‚­ã®ç·CXæšæ•°ãƒã‚§ãƒƒã‚¯ (ä»®: 8æš)
                if (cxCount + initialDiscardCx > 8) {
                    showCustomMessage(`è­¦å‘Š: å±±æœ­ã¨æ§ãˆå®¤ã®CXåˆè¨ˆãŒ ${cxCount + initialDiscardCx} æšã§ã™ã€‚ (é€šå¸¸ã¯8æš)`, 'red');
                }


                // 4. è¨ˆç®—å®Ÿè¡Œ
                await new Promise(resolve => setTimeout(resolve, 10)); 

                const startTime = performance.now();
                // æ§ãˆå®¤æƒ…å ±ã‚’æ¸¡ã™
                const probabilities = simulator.runSimulation(
                    initialDeckSize, cxCount, 
                    initialDiscardCx, initialDiscardUnCx, 
                    actions, simulations, applyRefreshDamage
                );
                const endTime = performance.now();
                
                // 5. çµæœã®è¡¨ç¤º
                const settings = { 
                    simulations, initialDeckSize, cxCount, 
                    initialDiscardCx, initialDiscardUnCx, 
                    actions, applyRefreshDamage 
                };
                displayResults(probabilities, settings, endTime - startTime);

            } catch (error) {
                console.error(error);
                resultsOutput.innerHTML = `<div class="p-3 bg-red-100 border border-red-400 text-red-700 rounded-lg">${error.message}</div>`;
            } finally {
                // 6. UIçŠ¶æ…‹ã‚’å…ƒã«æˆ»ã™
                runButton.disabled = false;
                statusMessage.classList.add('hidden');
            }
        }


        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚: 1. è¨­å®šã‚’èª­ã¿è¾¼ã‚€
        window.onload = () => {
             loadSettings();
        };
    </script>
</body>
</html>
