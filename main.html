<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ´ã‚¡ã‚¤ã‚¹ã‚·ãƒ¥ãƒ´ã‚¡ãƒ«ãƒ„ ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚¿ã‚¤ãƒ« */
        .card-shadow {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 4px, 6px, 0.05);
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 sm:p-8 font-sans">

    <div id="app" class="max-w-4xl mx-auto">
        <header class="text-center mb-10 p-4 bg-white rounded-xl shadow-lg">
            <h1 class="text-3xl font-extrabold text-indigo-700">ãƒ´ã‚¡ã‚¤ã‚¹ã‚·ãƒ¥ãƒ´ã‚¡ãƒ«ãƒ„ ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</h1>
            <p class="text-sm text-gray-600 mt-2">ï¼ˆãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å‘¨ã‚Šã¯ä»®å¯¾å¿œï¼‰</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- è¨­å®šå…¥åŠ›ã‚¨ãƒªã‚¢ -->
            <div class="lg:col-span-1 p-6 bg-white rounded-xl card-shadow h-fit">
                <h2 class="text-xl font-bold mb-4 text-gray-800 border-b pb-2">ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š</h2>
                
                <div class="space-y-4">
                    <!-- åˆæœŸå±±æœ­æšæ•° -->
                    <div>
                        <label for="deckSize" class="block text-sm font-medium text-gray-700">åˆæœŸå±±æœ­æšæ•° (Deck Size)</label>
                        <input type="number" id="deckSize" value="20" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border">
                    </div>

                    <!-- CXæšæ•° -->
                    <div>
                        <label for="cxCount" class="block text-sm font-medium text-gray-700">CXæšæ•° (Climax Count)</label>
                        <input type="number" id="cxCount" value="5" min="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border">
                    </div>

                    <!-- ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ— -->
                    <div>
                        <label for="damages" class="block text-sm font-medium text-gray-700">ä¸ãˆã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ— (m:ãƒ¢ã‚«, u:ãƒˆãƒƒãƒ—ç››ã‚Š, ä¾‹: 2m,3u,3)</label>
                        <input type="text" id="damages" value="2m,3,3,2,3,3" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border" placeholder="ä¾‹: 2m,3u,3">
                    </div>

                    <!-- ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒ€ãƒ¡ãƒ¼ã‚¸ON/OFF -->
                    <div class="flex items-center pt-2">
                        <input type="checkbox" id="refreshToggle" checked class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                        <label for="refreshToggle" class="ml-2 block text-sm font-medium text-gray-700">ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒã‚¤ãƒ³ãƒˆã‚’é©ç”¨</label>
                    </div>

                    <!-- ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å›æ•° -->
                    <div>
                        <label for="simulations" class="block text-sm font-medium text-gray-700">ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å›æ•°</label>
                        <input type="number" id="simulations" value="50000" min="1000" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border">
                    </div>
                </div>

                <button id="runButton" onclick="handleSimulation()" class="mt-6 w-full py-3 px-4 border border-transparent rounded-md shadow-sm text-lg font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition duration-150 ease-in-out">
                    ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
                </button>
            </div>

            <!-- çµæœè¡¨ç¤ºã‚¨ãƒªã‚¢ -->
            <div class="lg:col-span-2 p-6 bg-white rounded-xl card-shadow">
                <h2 class="text-xl font-bold mb-4 text-gray-800 border-b pb-2">çµæœ</h2>
                <div id="statusMessage" class="mb-4 text-center text-indigo-600 font-semibold hidden">
                    è¨ˆç®—ä¸­ã§ã™...
                </div>
                
                <div id="resultsOutput" class="space-y-3">
                    <p class="text-gray-500">å®Ÿè¡Œãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚</p>
                </div>

                <div id="summary" class="mt-6 pt-4 border-t border-gray-200">
                    <p id="summaryText" class="text-sm text-gray-600"></p>
                </div>
            </div>
        </main>
    </div>

    <script>
        // TypeScriptã®å‹ãƒ’ãƒ³ãƒˆã‚’æ¨¡å€£
        /** @typedef {'CX' | 'UnCX'} Card */
        /** @typedef {Object.<number, number>} DamageCounts */
        /** @typedef {Object.<number, number>} CumulativeProbabilities */
        /** @typedef {{amount: number, hasMoka: boolean, hasUnCXTop: boolean}} DamageItem */

        const Card = {
            CX: 'CX',
            UnCX: 'UnCX'
        };
        
        // ====================================================================
        // ğŸ› ï¸ è¨­å®šä¿å­˜ãƒ»èª­ã¿è¾¼ã¿é–¢æ•°
        // ====================================================================

        /**
         * ç¾åœ¨ã®å…¥åŠ›å€¤ã‚’localStorageã«ä¿å­˜ã™ã‚‹ã€‚
         */
        function saveSettings() {
            localStorage.setItem('ws_deckSize', document.getElementById('deckSize').value);
            localStorage.setItem('ws_cxCount', document.getElementById('cxCount').value);
            localStorage.setItem('ws_damages', document.getElementById('damages').value);
            localStorage.setItem('ws_simulations', document.getElementById('simulations').value);
            localStorage.setItem('ws_refreshToggle', document.getElementById('refreshToggle').checked);
        }

        /**
         * localStorageã‹ã‚‰å€¤ã‚’èª­ã¿è¾¼ã¿ã€å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«è¨­å®šã™ã‚‹ã€‚
         * æœ€åˆã«å€¤ãŒãªã‘ã‚Œã°ã€HTMLã«è¨­å®šã•ã‚ŒãŸãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨ã™ã‚‹ã€‚
         */
        function loadSettings() {
            const deckSizeInput = document.getElementById('deckSize');
            const cxCountInput = document.getElementById('cxCount');
            const damagesInput = document.getElementById('damages');
            const simulationsInput = document.getElementById('simulations');
            const refreshToggleInput = document.getElementById('refreshToggle');

            deckSizeInput.value = localStorage.getItem('ws_deckSize') || deckSizeInput.value;
            cxCountInput.value = localStorage.getItem('ws_cxCount') || cxCountInput.value;
            damagesInput.value = localStorage.getItem('ws_damages') || damagesInput.value;
            simulationsInput.value = localStorage.getItem('ws_simulations') || simulationsInput.value;
            
            const refreshToggleValue = localStorage.getItem('ws_refreshToggle');
            if (refreshToggleValue !== null) {
                refreshToggleInput.checked = refreshToggleValue === 'true';
            }
        }

        // ====================================================================
        // ãƒ´ã‚¡ã‚¤ã‚¹ã‚·ãƒ¥ãƒ´ã‚¡ãƒ«ãƒ„ ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ ã‚¯ãƒ©ã‚¹ 
        // ====================================================================

        class WeissDamageSimulator {
            constructor() {
                this.rng = Math; // JavaScriptã®Mathã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¹±æ•°æºã¨ã—ã¦ä½¿ç”¨
                /** @type {Card[]} */
                this.discardPile = []; // æ§ãˆå®¤
            }

            /**
             * å±±æœ­ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹ï¼ˆãƒ•ã‚£ãƒƒã‚·ãƒ£ãƒ¼ãƒ»ã‚¤ã‚§ãƒ¼ãƒ„ãƒ»ã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼‰
             * @param {Card[]} deck 
             */
            _shuffle(deck) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
            }

            /**
             * ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å‡¦ç†ã‚’å®Ÿè¡Œã—ã€ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è¿½åŠ ã™ã‚‹ã€‚
             * @param {Card[]} deck - ç¾åœ¨ã®å±±æœ­
             * @param {number} totalPassedDamage - ç¾æ™‚ç‚¹ã§ã®ç´¯ç©ãƒ€ãƒ¡ãƒ¼ã‚¸
             * @param {boolean} applyRefreshDamage - ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’é©ç”¨ã™ã‚‹ã‹ã©ã†ã‹
             * @returns {[number, Card[]]} - [è¿½åŠ ã•ã‚ŒãŸãƒ€ãƒ¡ãƒ¼ã‚¸, æ–°ã—ã„å±±æœ­]
             */
            _refresh(deck, totalPassedDamage, applyRefreshDamage) {
                // 1. ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒ€ãƒ¡ãƒ¼ã‚¸(1ç‚¹)
                const addedDamage = applyRefreshDamage ? 1 : 0; // RPè¨­å®šã«å¿œã˜ã¦ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’æ±ºå®š

                // 2. æ§ãˆå®¤ã®ã‚«ãƒ¼ãƒ‰ã‚’å±±æœ­ã«æˆ»ã—ã¦ã‚·ãƒ£ãƒƒãƒ•ãƒ«
                deck.push(...this.discardPile);
                this.discardPile = []; // æ§ãˆå®¤ã‚’ç©ºã«ã™ã‚‹
                this._shuffle(deck);

                return [addedDamage, deck];
            }
            
            /**
             * ãƒ¢ã‚«èƒ½åŠ›å‡¦ç†: å±±æœ­ä¸Š2æšã¾ã§è¦‹ã¦CXã‚’æ§ãˆå®¤ã«ç½®ãã€æ®‹ã‚Šã‚’å±±æœ­ãƒˆãƒƒãƒ—ã«æˆ»ã™ã€‚
             * @param {Card[]} currentDeck 
             */
            _processMokaEffect(currentDeck) {
                if (currentDeck.length === 0) return;

                // 1. å±±æœ­ã®ä¸Šã‹ã‚‰2æšã¾ã§è¦‹ã‚‹ï¼ˆå±±æœ­ã‹ã‚‰å–ã‚Šé™¤ãï¼‰
                const revealedCards = currentDeck.splice(0, 2); 
                
                /** @type {Card[]} */
                const cxCards = [];
                /** @type {Card[]} */
                const otherCards = [];

                // 2. CXã¨ãã®ä»–ã®ã‚«ãƒ¼ãƒ‰ã‚’åˆ†é¡
                for (const card of revealedCards) {
                    if (card === Card.CX && cxCards.length < 2) {
                        cxCards.push(card); // æœ€å¤§2æšã®CXã‚’æ§å®¤ã¸
                    } else {
                        otherCards.push(card); // ãã‚Œä»¥å¤–ã®ã‚«ãƒ¼ãƒ‰ã¯å±±æœ­ãƒˆãƒƒãƒ—ã¸
                    }
                }

                // 3. CXã‚’æ§ãˆå®¤ã«ç½®ã
                this.discardPile.push(...cxCards);

                // 4. æ®‹ã‚Šã®ã‚«ãƒ¼ãƒ‰ã‚’å±±æœ­ã®ä¸Šã«å¥½ããªé †ç•ªã§ç½®ã
                currentDeck.unshift(...otherCards);
            }

            /**
             * UnCXãƒˆãƒƒãƒ—è¿½åŠ å‡¦ç†: å±±æœ­ã®ä¸€ç•ªä¸Šã«æ–°ã—ãCXã§ã¯ãªã„ã‚«ãƒ¼ãƒ‰ã‚’ç½®ãã€‚
             * å±±æœ­ã®æšæ•°ãŒ1æšå¢—ãˆã‚‹ã€‚
             * @param {Card[]} currentDeck 
             */
            _processUnCXTopEffect(currentDeck) {
                // å±±æœ­ã®ä¸€ç•ªä¸Šã«UnCXã‚’æŒ¿å…¥
                // JavaScriptã®unshiftã¯é…åˆ—ã®å…ˆé ­ã«è¦ç´ ã‚’è¿½åŠ ã™ã‚‹ï¼ˆå±±æœ­ã®ãƒˆãƒƒãƒ—ã«ç½®ãæ“ä½œã«ç›¸å½“ï¼‰
                currentDeck.unshift(Card.UnCX);
                
                // æ³¨æ„: ã“ã®æ“ä½œã¯ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹æ™‚ã®åˆæœŸCX/UnCXæ¯”ç‡ã‚’å´©ã™ãŒã€
                // å±±æœ­å¤–ã‹ã‚‰ã‚«ãƒ¼ãƒ‰ã‚’ç½®ãåŠ¹æœã‚’æŒã¤ã‚«ãƒ¼ãƒ‰ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«æœ‰åŠ¹
            }


            /**
             * 1å›ã®ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†ã‚’å®Ÿè¡Œã—ã€å®Ÿéš›ã«é€šã£ãŸãƒ€ãƒ¡ãƒ¼ã‚¸ã¨ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è¿”ã™ã€‚
             * @param {Card[]} currentDeck - ç¾åœ¨ã®å±±æœ­ï¼ˆã“ã®é–¢æ•°å†…ã§å¤‰æ›´ã•ã‚Œã‚‹ï¼‰
             * @param {number} damageAmount - ãƒ€ãƒ¡ãƒ¼ã‚¸ç‚¹æ•°N
             * @param {number} totalPassedDamage - ç¾æ™‚ç‚¹ã§ã®ç´¯ç©ãƒ€ãƒ¡ãƒ¼ã‚¸ç‚¹æ•°
             * @param {boolean} applyRefreshDamage - ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’é©ç”¨ã™ã‚‹ã‹ã©ã†ã‹
             * @returns {[number, number]} - [å®Ÿéš›ã«é€šã£ãŸãƒ€ãƒ¡ãƒ¼ã‚¸, ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã«ã‚ˆã‚‹è¿½åŠ ãƒ€ãƒ¡ãƒ¼ã‚¸]
             */
            _processDamage(currentDeck, damageAmount, totalPassedDamage, applyRefreshDamage) {
                let passedDamage = 0;
                let refreshDamage = 0;
                let isCancelled = false;

                // ãƒ€ãƒ¡ãƒ¼ã‚¸ç‚¹æ•°ï¼ˆdamageAmountï¼‰ã®æœ€å¤§æšæ•°ã¾ã§1æšãšã¤ã‚ãã‚‹
                for (let i = 0; i < damageAmount; i++) {
                    // 1. å±±æœ­ãŒç©ºã«ãªã£ãŸã‚‰ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å‡¦ç†
                    if (currentDeck.length === 0) {
                        // ãƒ•ãƒ©ã‚°ã‚’æ¸¡ã™
                        const [addedDamage, newDeck] = this._refresh(currentDeck, totalPassedDamage, applyRefreshDamage);
                        refreshDamage += addedDamage;
                        totalPassedDamage += addedDamage; // ç´¯ç©ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’æ›´æ–°
                        currentDeck = newDeck; // å±±æœ­ã‚’æ›´æ–°

                        // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å¾Œã‚‚å±±æœ­ãŒç©ºãªã‚‰ã€ã‚ãã‚‹å‡¦ç†ã‚’çµ‚äº†
                        if (currentDeck.length === 0) {
                            break;
                        }
                    }

                    // 2. å±±æœ­ã®å…ˆé ­ã‹ã‚‰1æšã‚ãã‚Šã€å±±æœ­ã‹ã‚‰å–ã‚Šé™¤ã
                    const drawnCard = currentDeck.shift(); // .shift() ã¯æœ€åˆã®è¦ç´ ã‚’å–ã‚Šé™¤ã

                    // 3. CXãƒã‚§ãƒƒã‚¯: 1æšã§ã‚‚CXãŒå‡ºãŸã‚‰ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                    if (drawnCard === Card.CX) {
                        isCancelled = true;
                        this.discardPile.push(drawnCard);
                        passedDamage = 0;
                        break; // CXãŒå‡ºãŸã®ã§ã€ãã®æ™‚ç‚¹ã§ã‚ãã‚‹ã®ã‚’ã‚¹ãƒˆãƒƒãƒ—
                    }

                    // 4. CXãŒå‡ºãªã‘ã‚Œã°ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒé€šã‚‹
                    passedDamage++;
                    this.discardPile.push(drawnCard); // CXãŒå‡ºãªã‹ã£ãŸã‚«ãƒ¼ãƒ‰ã‚’æ§ãˆå®¤ã¸
                }

                return [passedDamage, refreshDamage];
            }

            /**
             * ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã€ãƒ€ãƒ¡ãƒ¼ã‚¸ç‚¹æ•°ã”ã¨ã®ç´¯ç©ç¢ºç‡ã‚’è¿”ã™ã€‚
             * @param {number} initialDeckSize 
             * @param {number} cxCount 
             * @param {DamageItem[]} damages 
             * @param {number} simulations 
             * @param {boolean} applyRefreshDamage - ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’é©ç”¨ã™ã‚‹ã‹ã©ã†ã‹
             * @returns {CumulativeProbabilities}
             */
            runSimulation(initialDeckSize, cxCount, damages, simulations, applyRefreshDamage) {
                /** @type {DamageCounts} */
                const damageCounts = {};
                const unCxCount = initialDeckSize - cxCount;
                
                // æœ€å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸ã¯ã€å…¨ã¦ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒé€šã‚Šï¼ˆdamageã®åˆè¨ˆï¼‰ã€RPé©ç”¨ãªã‚‰+1
                // ãŸã ã—UnCXãƒˆãƒƒãƒ—è¿½åŠ ã«ã‚ˆã‚Šå±±æœ­æšæ•°ãŒå¢—ãˆã‚‹ãŸã‚ã€å˜ç´”ãªåˆè¨ˆã‚ˆã‚Šå¤šããªã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŒã€
                // ã“ã“ã§ã¯ä¸Šé™å€¤ã‚’å³å¯†ã«è¨ˆç®—ã›ãšã€ååˆ†ã«å¤§ããªå€¤ï¼ˆãƒ€ãƒ¡ãƒ¼ã‚¸åˆ—ã®åˆè¨ˆï¼‹ãƒªãƒ•ãƒ€ãƒ¡ï¼‰ã¨ã™ã‚‹
                const maxPossibleDamage = damages.reduce((sum, d) => sum + d.amount, 0) + (applyRefreshDamage ? 1 : 0);

                for (let sim = 0; sim < simulations; sim++) {
                    // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã”ã¨ã®åˆæœŸåŒ–
                    this.discardPile = [];
                    
                    // 1. åˆæœŸå±±æœ­ã®ä½œæˆã¨ã‚·ãƒ£ãƒƒãƒ•ãƒ«
                    /** @type {Card[]} */
                    let deck = Array(cxCount).fill(Card.CX).concat(Array(unCxCount).fill(Card.UnCX));
                    this._shuffle(deck);

                    // 2. ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†ã®å®Ÿè¡Œ
                    let totalPassedDamage = 0;
                    
                    let currentDeck = deck; 
                    for (const damage of damages) {
                        
                        // ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†å‰ã®ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
                        while (currentDeck.length === 0) {
                            const [addedDamage, newDeck] = this._refresh(currentDeck, totalPassedDamage, applyRefreshDamage);
                            totalPassedDamage += addedDamage;
                            currentDeck = newDeck;
                            if (currentDeck.length === 0) break; // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å¾Œã‚‚ç©ºãªã‚‰çµ‚äº†
                        }
                        if (currentDeck.length === 0) break; // ãƒ€ãƒ¡ãƒ¼ã‚¸ã¯é€šã‚‰ãšæ¬¡ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã¸

                        // ğŸš¨ UnCXãƒˆãƒƒãƒ—è¿½åŠ èƒ½åŠ›é©ç”¨ãƒã‚§ãƒƒã‚¯
                        if (damage.hasUnCXTop) {
                            this._processUnCXTopEffect(currentDeck);
                            
                            // UnCXã®æŒ¿å…¥ã«ã‚ˆã‚Šå±±æœ­ã®é•·ã•ãŒå¤‰ã‚ã‚‹ãŒã€CXæšæ•°ã¯å¤‰ã‚ã‚‰ãªã„ã€‚
                            // å±±æœ­ãŒç©ºã§ã¯ãªã„çŠ¶æ…‹ã‹ã‚‰å§‹ã¾ã£ãŸå ´åˆã€ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯ã¯ä¸è¦ã€‚
                        }

                        // ãƒ¢ã‚«èƒ½åŠ›é©ç”¨ãƒã‚§ãƒƒã‚¯
                        if (damage.hasMoka) {
                            this._processMokaEffect(currentDeck);

                            // ãƒ¢ã‚«èƒ½åŠ›ã§å±±æœ­ãŒç©ºã«ãªã£ãŸå ´åˆã€ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†ã«å…¥ã‚‹å‰ã«å†åº¦ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
                            while (currentDeck.length === 0) {
                                const [addedDamage, newDeck] = this._refresh(currentDeck, totalPassedDamage, applyRefreshDamage);
                                totalPassedDamage += addedDamage;
                                currentDeck = newDeck;
                                if (currentDeck.length === 0) break; 
                            }
                        }
                        
                        if (currentDeck.length === 0) break; 
                        
                        // ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†ã‚’å®Ÿè¡Œ
                        const [passed, refreshAdded] = this._processDamage(currentDeck, damage.amount, totalPassedDamage, applyRefreshDamage);
                        totalPassedDamage += passed;
                        totalPassedDamage += refreshAdded; 
                    }

                    // 3. çµæœã®é›†è¨ˆ
                    damageCounts[totalPassedDamage] = (damageCounts[totalPassedDamage] || 0) + 1;
                }

                // 4. ç´¯ç©ç¢ºç‡ã®è¨ˆç®—
                /** @type {CumulativeProbabilities} */
                const cumulativeProbabilities = {};
                
                let cumulativeCount = 0;
                for (let d = maxPossibleDamage; d >= 1; d--) {
                    
                    cumulativeCount += damageCounts[d] || 0;
                    cumulativeProbabilities[d] = cumulativeCount / simulations;
                }

                return cumulativeProbabilities;
            }
        }

        // ====================================================================
        // ğŸš€ UIæ“ä½œã¨å®Ÿè¡Œé–¢æ•°
        // ====================================================================

        const simulator = new WeissDamageSimulator();
        const resultsOutput = document.getElementById('resultsOutput');
        const statusMessage = document.getElementById('statusMessage');
        const runButton = document.getElementById('runButton');
        const summaryText = document.getElementById('summaryText');

        /**
         * å…¥åŠ›ã‚’å–å¾—ã—ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã€çµæœã‚’è¡¨ç¤ºã™ã‚‹
         */
        async function handleSimulation() {
            // ğŸš¨ 1. å…¥åŠ›å€¤ã‚’ä¿å­˜
            saveSettings();
            
            // 2. UIçŠ¶æ…‹ã®æ›´æ–°
            runButton.disabled = true;
            statusMessage.textContent = 'è¨ˆç®—ä¸­ã§ã™... ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚';
            statusMessage.classList.remove('hidden');
            resultsOutput.innerHTML = '';
            summaryText.textContent = '';

            try {
                // 3. å…¥åŠ›ã®å–å¾—ã¨æ¤œè¨¼
                const initialDeckSize = parseInt(document.getElementById('deckSize').value);
                const cxCount = parseInt(document.getElementById('cxCount').value);
                const simulations = parseInt(document.getElementById('simulations').value);
                const applyRefreshDamage = document.getElementById('refreshToggle').checked;
                
                const damagesInput = document.getElementById('damages').value;
                
                /** @type {DamageItem[]} */
                const damages = damagesInput.split(',').map(s => {
                    const trimmed = s.trim();
                    const hasMoka = trimmed.toLowerCase().includes('m');
                    // UnCXãƒˆãƒƒãƒ—è¿½åŠ ãƒ•ãƒ©ã‚°
                    const hasUnCXTop = trimmed.toLowerCase().includes('u');
                    
                    // æ•°å­—éƒ¨åˆ†ã®ã¿ã‚’æŠ½å‡º
                    const amountStr = trimmed.replace(/[^0-9]/g, ''); 
                    const amount = parseInt(amountStr);
                    
                    if (isNaN(amount) || amount <= 0) return null;

                    return { amount, hasMoka, hasUnCXTop };
                }).filter(item => item !== null);

                if (initialDeckSize <= 0 || cxCount < 0 || simulations < 1000 || damages.length === 0) {
                    throw new Error("å…¥åŠ›å€¤ãŒä¸æ­£ã§ã™ã€‚æšæ•°ã‚„å›æ•°ã¯æ­£ã®æ•°ã€ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ—ã¯ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
                }
                if (cxCount > initialDeckSize) {
                    throw new Error("CXæšæ•°ãŒåˆæœŸå±±æœ­æšæ•°ã‚’è¶…ãˆã¦ã„ã¾ã™ã€‚CXæšæ•°ã‚’ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚");
                }

                // 4. è¨ˆç®—å®Ÿè¡Œ
                await new Promise(resolve => setTimeout(resolve, 10)); 

                const startTime = performance.now();
                // RPè¨­å®šã‚’æ¸¡ã™
                const probabilities = simulator.runSimulation(initialDeckSize, cxCount, damages, simulations, applyRefreshDamage);
                const endTime = performance.now();
                
                // 5. çµæœã®è¡¨ç¤º
                displayResults(probabilities, simulations, initialDeckSize, cxCount, damages, endTime - startTime);

            } catch (error) {
                console.error(error);
                resultsOutput.innerHTML = `<div class="p-3 bg-red-100 border border-red-400 text-red-700 rounded-lg">${error.message}</div>`;
            } finally {
                // 6. UIçŠ¶æ…‹ã‚’å…ƒã«æˆ»ã™
                runButton.disabled = false;
                statusMessage.classList.add('hidden');
            }
        }

        /**
         * çµæœã®ç¢ºç‡ãƒªã‚¹ãƒˆã‚’æ•´å½¢ã—ã¦è¡¨ç¤ºã™ã‚‹
         * @param {CumulativeProbabilities} probabilities 
         * @param {number} simulations 
         * @param {number} initialDeckSize 
         * @param {number} cxCount 
         * @param {DamageItem[]} damages 
         * @param {number} timeTaken 
         */
        function displayResults(probabilities, simulations, initialDeckSize, cxCount, damages, timeTaken) {
            resultsOutput.innerHTML = '';
            
            const maxDamageResult = Math.max(...Object.keys(probabilities).map(Number));
            const results = [];
            
            // è¡¨ç¤ºç”¨ã®ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ—æ–‡å­—åˆ—ã‚’ä½œæˆ (ãƒ¢ã‚«/UnCXãƒˆãƒƒãƒ—ãƒ•ãƒ©ã‚°ä»˜ã)
            const damagesString = damages.map(d => `${d.amount}${d.hasMoka ? 'm' : ''}${d.hasUnCXTop ? 'u' : ''}`).join(', ');

            // 1ç‚¹ã‹ã‚‰æœ€å¤§ç‚¹æ•°ã¾ã§è¡¨ç¤º
            for (let d = 1; d <= maxDamageResult; d++) {
                const prob = probabilities[d] || 0.0;
                
                // ãƒãƒ¼ã®è‰²ã¨å¹…ã‚’è¨ˆç®—
                const percentage = (prob * 100).toFixed(2);
                const barWidth = Math.max(percentage, 1); // 0%ã§ã‚‚ãƒãƒ¼ã®ãƒ©ã‚¤ãƒ³ãŒè¦‹ãˆã‚‹ã‚ˆã†ã«æœ€å°1ã‚’è¨­å®š
                const barColor = prob >= 0.7 ? 'bg-green-500' : prob >= 0.4 ? 'bg-yellow-500' : 'bg-red-500';

                results.push(`
                    <div class="flex items-center space-x-2">
                        <span class="font-mono text-sm w-12 text-gray-500">${d}ç‚¹ä»¥ä¸Š:</span>
                        <div class="flex-grow bg-gray-200 rounded-full h-4">
                            <div class="${barColor} h-4 rounded-full" style="width: ${barWidth}%;"></div>
                        </div>
                        <span class="font-semibold w-16 text-right">${percentage}%</span>
                    </div>
                `);
            }

            resultsOutput.innerHTML = results.join('');

            summaryText.textContent = `
                è¨­å®šï¼šå±±æœ­${initialDeckSize}æš (CX${cxCount}æš), ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ— ${damagesString}ã€‚
                ${simulations}å›ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ ${(timeTaken / 1000).toFixed(3)} ç§’ã§å®Ÿè¡Œã—ã¾ã—ãŸã€‚
            `;
            
        }

        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚: 1. è¨­å®šã‚’èª­ã¿è¾¼ã‚€ -> 2. ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è‡ªå‹•å®Ÿè¡Œã™ã‚‹
        window.onload = () => {
             loadSettings(); // ä¿æŒã—ãŸè¨­å®šã‚’ãƒ­ãƒ¼ãƒ‰
             handleSimulation().catch(e => console.log("åˆæœŸã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼:", e));
        };
    </script>
</body>
</html>
