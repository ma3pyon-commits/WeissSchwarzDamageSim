<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ヴァイスシュヴァルツ ダメージシミュレーター</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* カスタムスタイル */
        .card-shadow {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 4px, 6px, 0.05);
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 sm:p-8 font-sans">

    <div id="app" class="max-w-4xl mx-auto">
        <header class="text-center mb-10 p-4 bg-white rounded-xl shadow-lg">
            <h1 class="text-3xl font-extrabold text-indigo-700">ヴァイスシュヴァルツ ダメージシミュレーター</h1>
            <p class="text-sm text-gray-600 mt-2">（リフレッシュ関連は仮実装）</p>
        </header>

        <main class="grid grid-cols-1 lg:col-cols-3 gap-8">
            <!-- 設定入力エリア -->
            <div class="lg:col-span-1 p-6 bg-white rounded-xl card-shadow h-fit">
                <h2 class="text-xl font-bold mb-4 text-gray-800 border-b pb-2">シミュレーション設定</h2>
                
                <div class="space-y-4">
                    <!-- 初期山札枚数 -->
                    <div>
                        <label for="deckSize" class="block text-sm font-medium text-gray-700">初期山札枚数</label><!-- (Deck Size)を削除 -->
                        <input type="number" id="deckSize" value="28" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border">
                    </div>

                    <!-- CX枚数 -->
                    <div>
                        <label for="cxCount" class="block text-sm font-medium text-gray-700">CX枚数</label><!-- (Climax Count)を削除 -->
                        <input type="number" id="cxCount" value="8" min="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border">
                    </div>

                    <!-- ダメージ列 (説明ボタンを追加) -->
                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <label for="damages" class="block text-sm font-medium text-gray-700">与えるダメージ列</label>
                            <button onclick="showExplanationModal()" class="text-xs font-semibold text-indigo-600 hover:text-indigo-800 underline">
                                説明を見る
                            </button>
                        </div>
                        <input type="text" id="damages" value="1,3,3,3" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border" placeholder="例: 4,3c,2m,3u,1b">
                    </div>

                    <!-- リフレッシュダメージON/OFF -->
                    <div class="flex items-center pt-2">
                        <input type="checkbox" id="refreshToggle" checked class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                        <label for="refreshToggle" class="ml-2 block text-sm font-medium text-gray-700">リフレッシュポイントを適用</label>
                    </div>

                    <!-- シミュレーション回数 -->
                    <div>
                        <label for="simulations" class="block text-sm font-medium text-gray-700">シミュレーション回数</label>
                        <input type="number" id="simulations" value="50000" min="1000" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border">
                    </div>
                </div>

                <button id="runButton" onclick="handleSimulation()" class="mt-6 w-full py-3 px-4 border border-transparent rounded-md shadow-sm text-lg font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition duration-150 ease-in-out">
                    シミュレーション実行
                </button>
            </div>

            <!-- 結果表示エリア -->
            <div class="lg:col-span-2 p-6 bg-white rounded-xl card-shadow">
                <h2 class="text-xl font-bold mb-4 text-gray-800 border-b pb-2">結果</h2>
                <div id="statusMessage" class="mb-4 text-center text-indigo-600 font-semibold hidden">
                    計算中です...
                </div>
                
                <div id="resultsOutput" class="space-y-3">
                    <p class="text-gray-500">実行ボタンを押してシミュレーションを開始してください。</p>
                </div>

                <div id="summary" class="mt-6 pt-4 border-t border-gray-200">
                    <p id="summaryText" class="text-sm text-gray-600"></p>
                </div>
            </div>
        </main>
        
        <!-- 署名フッターの追加 -->
        <footer class="mt-8 text-center text-sm text-gray-500 p-4">
            <p>Thanks for visiting! – PineAme@tcepseredutitta</p>
        </footer>
        <!---------------------->

        <!-- ダメージ列説明モーダル -->
        <div id="explanationModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 hidden transition-opacity duration-300 items-center justify-center p-4" onclick="if (event.target === this) closeExplanationModal()">
            <div class="bg-white rounded-xl shadow-2xl max-w-lg w-full p-6 transform transition-all duration-300 scale-95 opacity-0" id="modalContent">
                <div class="flex justify-between items-center border-b pb-3 mb-4">
                    <h3 class="text-xl font-bold text-indigo-700">ダメージ列 凡例</h3>
                    <button onclick="closeExplanationModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                <div class="text-gray-700 space-y-3">
                    <p class="font-semibold text-gray-800">入力形式: カンマ区切りでアクションを記述 (例: 1,2u,3u,4m,5c)</p>
                    <ul class="list-disc list-inside space-y-2 pl-4">
                        <li><strong class="font-mono text-indigo-600">N</strong>: Nダメージ (N点ダメージを実行)</li>
                        <li><strong class="font-mono text-indigo-600">Nb</strong>: N枚逆圧縮 (N枚のCXでないカードを山札に加えてシャッフル)</li>
                        <li><strong class="font-mono text-indigo-600">Nu</strong>: 1枚トップ盛り + Nダメージ (CXでないカードをトップに追加後、Nダメージ)</li>
                        <li><strong class="font-mono text-indigo-600">Nm</strong>: モカ + Nダメージ (トップ2枚操作後、Nダメージ)</li>
                        <li><strong class="font-mono text-indigo-600">Nc</strong>: 直前がキャンセル時 Nダメージ (直前のダメージがキャンセルされていた場合のみNダメージを実行)</li>
                    </ul>
                </div>
                <button onclick="closeExplanationModal()" class="mt-6 w-full py-2 bg-indigo-600 text-white rounded-lg shadow hover:bg-indigo-700 transition">閉じる</button>
            </div>
        </div>

    </div>

    <script>
        // TypeScriptの型ヒントを模倣
        /** @typedef {'CX' | 'UnCX'} Card */
        /** @typedef {Object.<number, number>} DamageCounts */
        /** @typedef {Object.<number, number>} CumulativeProbabilities */
        /** @typedef {{
             amount: number, 
             isDamage: boolean, 
             hasMoka: boolean, 
             hasUnCXTop: boolean,
             hasBuryShuffle: boolean,
             hasConditionalCancel: boolean // 条件付きダメージ(c)フラグを追加
           }} DamageItem 
        */

        const Card = {
            CX: 'CX',
            UnCX: 'UnCX'
        };
        
        // ====================================================================
        // 🛠️ 設定保存・読み込み関数
        // ====================================================================

        /**
         * 現在の入力値をlocalStorageに保存する。
         */
        function saveSettings() {
            localStorage.setItem('ws_deckSize', document.getElementById('deckSize').value);
            localStorage.setItem('ws_cxCount', document.getElementById('cxCount').value);
            localStorage.setItem('ws_damages', document.getElementById('damages').value);
            localStorage.setItem('ws_simulations', document.getElementById('simulations').value);
            localStorage.setItem('ws_refreshToggle', document.getElementById('refreshToggle').checked);
        }

        /**
         * localStorageから値を読み込み、入力フィールドに設定する。
         * 最初に値がなければ、HTMLに設定されたデフォルト値を使用する。
         */
        function loadSettings() {
            const deckSizeInput = document.getElementById('deckSize');
            const cxCountInput = document.getElementById('cxCount');
            const damagesInput = document.getElementById('damages');
            const simulationsInput = document.getElementById('simulations');
            const refreshToggleInput = document.getElementById('refreshToggle');

            deckSizeInput.value = localStorage.getItem('ws_deckSize') || deckSizeInput.value;
            cxCountInput.value = localStorage.getItem('ws_cxCount') || cxCountInput.value;
            // 初期値を1,3,3,3に設定 (修正済み)
            damagesInput.value = localStorage.getItem('ws_damages') || "1,3,3,3";
            simulationsInput.value = localStorage.getItem('ws_simulations') || simulationsInput.value;
            
            const refreshToggleValue = localStorage.getItem('ws_refreshToggle');
            if (refreshToggleValue !== null) {
                refreshToggleInput.checked = refreshToggleValue === 'true';
            }
        }

        // ====================================================================
        // ヴァイスシュヴァルツ ダメージシミュレーター クラス 
        // ====================================================================

        class WeissDamageSimulator {
            constructor() {
                this.rng = Math; // JavaScriptのMathオブジェクトを乱数源として使用
                /** @type {Card[]} */
                this.discardPile = []; // 控え室
            }

            /**
             * 山札をシャッフルする（フィッシャー・イェーツ・シャッフル）
             * @param {Card[]} deck 
             */
            _shuffle(deck) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
            }

            /**
             * リフレッシュ処理を実行し、リフレッシュダメージを追加する。
             * @param {Card[]} deck - 現在の山札
             * @param {number} totalPassedDamage - 現時点での累積ダメージ
             * @param {boolean} applyRefreshDamage - リフレッシュダメージを適用するかどうか
             * @returns {[number, Card[]]} - [追加されたダメージ, 新しい山札]
             */
            _refresh(deck, totalPassedDamage, applyRefreshDamage) {
                // 1. リフレッシュダメージ(1点)
                const addedDamage = applyRefreshDamage ? 1 : 0; // RP設定に応じてダメージを決定

                // 2. 控え室のカードを山札に戻してシャッフル
                deck.push(...this.discardPile);
                this.discardPile = []; // 控え室を空にする
                this._shuffle(deck);

                return [addedDamage, deck];
            }
            
            /**
             * モカ能力処理: 山札上2枚まで見てCXを控え室に置き、残りを山札トップに戻す。
             * @param {Card[]} currentDeck 
             */
            _processMokaEffect(currentDeck) {
                if (currentDeck.length === 0) return;

                // 1. 山札の上から2枚まで見る（山札から取り除く）
                const revealedCards = currentDeck.splice(0, 2); 
                
                /** @type {Card[]} */
                const cxCards = [];
                /** @type {Card[]} */
                const otherCards = [];

                // 2. CXとその他のカードを分類
                for (const card of revealedCards) {
                    if (card === Card.CX && cxCards.length < 2) {
                        cxCards.push(card); // 最大2枚のCXを控室へ
                    } else {
                        otherCards.push(card); // それ以外のカードは山札トップへ
                    }
                }

                // 3. CXを控え室に置く
                this.discardPile.push(...cxCards);

                // 4. 残りのカードを山札の上に好きな順番で置く
                currentDeck.unshift(...otherCards);
            }

            /**
             * UnCXトップ追加処理: 山札の一番上に新しくCXではないカードを置く。
             * 山札の枚数が1枚増える。
             * @param {Card[]} currentDeck 
             */
            _processUnCXTopEffect(currentDeck) {
                // 山札の一番上にUnCXを挿入
                currentDeck.unshift(Card.UnCX);
            }

            /**
             * UnCX追加＆シャッフル処理: 指定枚数のUnCXを山札に加え、山札をシャッフルする。
             * @param {Card[]} currentDeck 
             * @param {number} count - 追加するUnCXの枚数
             */
            _processBuryShuffleEffect(currentDeck, count) {
                if (count <= 0) return;
                
                // 指定枚数のUnCXを山札に追加
                for (let i = 0; i < count; i++) {
                    currentDeck.push(Card.UnCX);
                }

                // 山札をシャッフル
                this._shuffle(currentDeck);
            }


            /**
             * 1回のダメージ処理を実行し、実際に通ったダメージとリフレッシュダメージを返す。
             * @param {Card[]} currentDeck - 現在の山札（この関数内で変更される）
             * @param {number} damageAmount - ダメージ点数N
             * @param {number} totalPassedDamage - 現時点での累積ダメージ点数
             * @param {boolean} applyRefreshDamage - リフレッシュダメージを適用するかどうか
             * @returns {[number, number, boolean]} - [実際に通ったダメージ, リフレッシュによる追加ダメージ, キャンセルされたかどうか]
             */
            _processDamage(currentDeck, damageAmount, totalPassedDamage, applyRefreshDamage) {
                let passedDamage = 0;
                let refreshDamage = 0;
                let isCancelled = false;

                // ダメージ点数（damageAmount）の最大枚数まで1枚ずつめくる
                for (let i = 0; i < damageAmount; i++) {
                    // 1. 山札が空になったらリフレッシュ処理
                    if (currentDeck.length === 0) {
                        // フラグを渡す
                        const [addedDamage, newDeck] = this._refresh(currentDeck, totalPassedDamage, applyRefreshDamage);
                        refreshDamage += addedDamage;
                        totalPassedDamage += addedDamage; // 累積ダメージを更新
                        currentDeck = newDeck; // 山札を更新

                        // リフレッシュ後も山札が空なら、めくる処理を終了
                        if (currentDeck.length === 0) {
                            break;
                        }
                    }

                    // 2. 山札の先頭から1枚めくり、山札から取り除く
                    const drawnCard = currentDeck.shift(); // .shift() は最初の要素を取り除く

                    // 3. CXチェック: 1枚でもCXが出たらキャンセル
                    if (drawnCard === Card.CX) {
                        isCancelled = true;
                        this.discardPile.push(drawnCard);
                        passedDamage = 0;
                        break; // CXが出たので、その時点でめくるのをストップ
                    }

                    // 4. CXが出なければダメージが通る
                    passedDamage++;
                    this.discardPile.push(drawnCard); // CXが出なかったカードを控え室へ
                }
                
                // ダメージが0点以上で、かつ実際に通ったダメージが0だった場合、キャンセルされたと判定
                // (damageAmount > 0) は、空山札などで実質ダメージが0になるケースを除外するため。
                const finalCancellationStatus = (damageAmount > 0 && passedDamage === 0);

                return [passedDamage, refreshDamage, finalCancellationStatus];
            }

            /**
             * シミュレーションを実行し、ダメージ点数ごとの累積確率を返す。
             * @param {number} initialDeckSize 
             * @param {number} cxCount 
             * @param {DamageItem[]} actions 
             * @param {number} simulations 
             * @param {boolean} applyRefreshDamage - リフレッシュダメージを適用するかどうか
             * @returns {CumulativeProbabilities}
             */
            runSimulation(initialDeckSize, cxCount, actions, simulations, applyRefreshDamage) {
                /** @type {DamageCounts} */
                const damageCounts = {};
                const unCxCount = initialDeckSize - cxCount;
                
                // 最大ダメージは、ダメージアクションの合計＋リフレッシュダメージ(最大1回)を暫定とする
                const maxPossibleDamage = actions
                    .filter(a => a.isDamage)
                    .reduce((sum, d) => sum + d.amount, 0) + (applyRefreshDamage ? 1 : 0);

                for (let sim = 0; sim < simulations; sim++) {
                    // シミュレーションごとの初期化
                    this.discardPile = [];
                    
                    // 1. 初期山札の作成とシャッフル
                    /** @type {Card[]} */
                    let deck = Array(cxCount).fill(Card.CX).concat(Array(unCxCount).fill(Card.UnCX));
                    this._shuffle(deck);

                    // 2. アクション処理の実行
                    let totalPassedDamage = 0;
                    let lastDamageCancelled = false; // 直前のダメージアクションがキャンセルされたか
                    
                    let currentDeck = deck; 
                    for (const action of actions) {
                        
                        // 2a. 山札にカードを加えてシャッフルするアクション (Nb)
                        if (action.hasBuryShuffle) {
                            this._processBuryShuffleEffect(currentDeck, action.amount);
                            // Nbの場合、lastDamageCancelled の状態は維持される
                            continue; // ダメージ処理は行わない
                        }
                        
                        // 2b. 条件付きダメージアクションのチェック (Nc)
                        if (action.hasConditionalCancel) {
                            // 直前のダメージがキャンセルされていない場合、このアクションはスキップ
                            if (!lastDamageCancelled) {
                                // 実行されなかった場合、LDCは変更しない（falseのまま）
                                continue;
                            }
                            // キャンセルされていた場合、通常のダメージとして処理を続行
                            // このアクションの結果が次の LDC を上書きします (後続の処理で実行)。
                        }
                        
                        // 2c. ダメージアクションの場合 (N, Nm, Nu, および条件が満たされたNc)
                        
                        // ダメージ処理前のリフレッシュチェック（山札が空の場合）
                        while (currentDeck.length === 0) {
                            const [addedDamage, newDeck] = this._refresh(currentDeck, totalPassedDamage, applyRefreshDamage);
                            totalPassedDamage += addedDamage;
                            currentDeck = newDeck;
                            if (currentDeck.length === 0) break; // リフレッシュ後も空なら終了
                        }
                        
                        // ダメージを実行する前に、特殊能力 (u, m) を適用
                        if (currentDeck.length > 0) { 
                             // UnCXトップ追加能力適用チェック
                            if (action.hasUnCXTop) {
                                this._processUnCXTopEffect(currentDeck);
                            }

                            // モカ能力適用チェック
                            if (action.hasMoka) {
                                this._processMokaEffect(currentDeck);

                                // モカ能力で山札が空になった場合、ダメージ処理に入る前に再度リフレッシュ
                                while (currentDeck.length === 0) {
                                    const [addedDamage, newDeck] = this._refresh(currentDeck, totalPassedDamage, applyRefreshDamage);
                                    totalPassedDamage += addedDamage;
                                    currentDeck = newDeck;
                                    if (currentDeck.length === 0) break; 
                                }
                            }
                        }
                        
                        let passedDamage = 0;
                        let refreshAdded = 0;
                        let isCurrentActionCancelled = false;
                        
                        if (currentDeck.length > 0) {
                            // ダメージ処理を実行
                            const results = this._processDamage(currentDeck, action.amount, totalPassedDamage, applyRefreshDamage);
                            passedDamage = results[0];
                            refreshAdded = results[1];
                            isCurrentActionCancelled = results[2];
                        } else {
                             // 山札が空の場合はダメージなしとして、キャンセル状態をFalseに設定
                             isCurrentActionCancelled = false;
                        }

                        totalPassedDamage += passedDamage;
                        totalPassedDamage += refreshAdded; 

                        // 3. このアクションがダメージアクションの結果としてキャンセルされたかどうかを記録
                        // (b以外のアクションは、その結果で LDC を上書きする)
                        lastDamageCancelled = isCurrentActionCancelled;
                    }

                    // 4. 結果の集計
                    damageCounts[totalPassedDamage] = (damageCounts[totalPassedDamage] || 0) + 1;
                }

                // 5. 累積確率の計算
                /** @type {CumulativeProbabilities} */
                const cumulativeProbabilities = {};
                
                let cumulativeCount = 0;
                for (let d = maxPossibleDamage; d >= 1; d--) {
                    
                    cumulativeCount += damageCounts[d] || 0;
                    cumulativeProbabilities[d] = cumulativeCount / simulations;
                }

                return cumulativeProbabilities;
            }
        }

        // ====================================================================
        // 🚀 UI操作と実行関数
        // ====================================================================

        const simulator = new WeissDamageSimulator();
        const resultsOutput = document.getElementById('resultsOutput');
        const statusMessage = document.getElementById('statusMessage');
        const runButton = document.getElementById('runButton');
        const summaryText = document.getElementById('summaryText');

        /**
         * ダメージ列の説明モーダルを表示する
         */
        function showExplanationModal() {
            const modal = document.getElementById('explanationModal');
            const content = document.getElementById('modalContent');
            
            modal.classList.remove('hidden');
            modal.classList.add('flex', 'opacity-0'); // hiddenを削除し、flexを追加して表示
            
            // アニメーションをトリガー
            setTimeout(() => {
                modal.classList.remove('opacity-0');
                content.classList.remove('scale-95', 'opacity-0');
            }, 10);
        }

        /**
         * ダメージ列の説明モーダルを閉じる
         */
        function closeExplanationModal() {
            const modal = document.getElementById('explanationModal');
            const content = document.getElementById('modalContent');

            // 逆アニメーションをトリガー
            content.classList.add('scale-95', 'opacity-0');
            modal.classList.add('opacity-0');

            // アニメーション完了後に非表示にする
            setTimeout(() => {
                modal.classList.add('hidden');
                modal.classList.remove('flex');
            }, 300); // Tailwind transition duration
        }


        /**
         * 入力を取得し、シミュレーションを実行し、結果を表示する
         */
        async function handleSimulation() {
            // 🚨 1. 入力値を保存
            saveSettings();
            
            // 2. UI状態の更新
            runButton.disabled = true;
            statusMessage.textContent = '計算中です... しばらくお待ちください。';
            statusMessage.classList.remove('hidden');
            resultsOutput.innerHTML = '';
            summaryText.textContent = '';

            try {
                // 3. 入力の取得と検証
                const initialDeckSize = parseInt(document.getElementById('deckSize').value);
                const cxCount = parseInt(document.getElementById('cxCount').value);
                const simulations = parseInt(document.getElementById('simulations').value);
                const applyRefreshDamage = document.getElementById('refreshToggle').checked;
                
                const damagesInput = document.getElementById('damages').value;
                
                /** @type {DamageItem[]} */
                const actions = damagesInput.split(',').map(s => {
                    const trimmed = s.trim();
                    const hasMoka = trimmed.toLowerCase().includes('m');
                    const hasUnCXTop = trimmed.toLowerCase().includes('u');
                    const hasBuryShuffle = trimmed.toLowerCase().includes('b');
                    const hasConditionalCancel = trimmed.toLowerCase().includes('c'); // <-- 追加
                    
                    // 数字部分のみを抽出
                    const amountStr = trimmed.replace(/[^0-9]/g, ''); 
                    const amount = parseInt(amountStr);
                    
                    if (isNaN(amount) || amount <= 0) return null;

                    // 'b' (Bury) は非ダメージアクション。それ以外はダメージアクション（条件付き含む）。
                    const isDamage = !hasBuryShuffle; 

                    return { amount, isDamage, hasMoka, hasUnCXTop, hasBuryShuffle, hasConditionalCancel };
                }).filter(item => item !== null);

                if (initialDeckSize <= 0 || cxCount < 0 || simulations < 1000 || actions.length === 0) {
                    throw new Error("入力値が不正です。枚数や回数は正の数、ダメージ列はカンマ区切りで入力してください。");
                }
                if (cxCount > initialDeckSize) {
                    throw new Error("CX枚数が初期山札枚数を超えています。CX枚数を修正してください。");
                }

                // 4. 計算実行
                // ブラウザが固まらないように非同期処理を挟む
                await new Promise(resolve => setTimeout(resolve, 10)); 

                const startTime = performance.now();
                // RP設定を渡す
                const probabilities = simulator.runSimulation(initialDeckSize, cxCount, actions, simulations, applyRefreshDamage);
                const endTime = performance.now();
                
                // 5. 結果の表示
                displayResults(probabilities, simulations, initialDeckSize, cxCount, actions, endTime - startTime);

            } catch (error) {
                console.error(error);
                resultsOutput.innerHTML = `<div class="p-3 bg-red-100 border border-red-400 text-red-700 rounded-lg">${error.message}</div>`;
            } finally {
                // 6. UI状態を元に戻す
                runButton.disabled = false;
                statusMessage.classList.add('hidden');
            }
        }

        /**
         * 結果の確率リストを整形して表示する
         * @param {CumulativeProbabilities} probabilities 
         * @param {number} simulations 
         * @param {number} initialDeckSize 
         * @param {number} cxCount 
         * @param {DamageItem[]} actions 
         * @param {number} timeTaken 
         */
        function displayResults(probabilities, simulations, initialDeckSize, cxCount, actions, timeTaken) {
            resultsOutput.innerHTML = '';
            
            const maxDamageResult = Math.max(...Object.keys(probabilities).map(Number));
            const results = [];
            
            // 表示用のダメージ列文字列を作成
            const damagesString = actions.map(d => {
                if (d.hasBuryShuffle) {
                    return `${d.amount}b`;
                }
                return `${d.amount}${d.hasMoka ? 'm' : ''}${d.hasUnCXTop ? 'u' : ''}${d.hasConditionalCancel ? 'c' : ''}`; // <-- 更新
            }).join(', ');

            // 1点から最大点数まで表示
            for (let d = 1; d <= maxDamageResult; d++) {
                const prob = probabilities[d] || 0.0;
                
                // バーの色と幅を計算
                const percentage = (prob * 100).toFixed(2);
                const barWidth = Math.max(percentage, 1); // 0%でもバーのラインが見えるように最小1を設定
                const barColor = prob >= 0.7 ? 'bg-green-500' : prob >= 0.4 ? 'bg-yellow-500' : 'bg-red-500';

                results.push(`
                    <div class="flex items-center space-x-2">
                        <span class="font-mono text-sm w-12 text-gray-500">${d}点以上:</span>
                        <div class="flex-grow bg-gray-200 rounded-full h-4">
                            <div class="${barColor} h-4 rounded-full" style="width: ${barWidth}%;"></div>
                        </div>
                        <span class="font-semibold w-16 text-right">${percentage}%</span>
                    </div>
                `);
            }

            resultsOutput.innerHTML = results.join('');

            summaryText.textContent = `
                設定：山札${initialDeckSize}枚 (CX${cxCount}枚), ダメージ列 ${damagesString}。
                ${simulations}回のシミュレーションを ${(timeTaken / 1000).toFixed(3)} 秒で実行しました。
            `;
            
        }

        // ページロード時: 1. 設定を読み込む -> 2. シミュレーションを自動実行する
        window.onload = () => {
             loadSettings(); // 保持した設定をロード
             handleSimulation().catch(e => console.log("初期シミュレーションエラー:", e));
        };
    </script>
</body>
</html>
