<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WSSolo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- SortableJSライブラリ -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
        }
        /* カスタムラジオボタンのスタイル */
        .location-radio-group label {
            cursor: pointer;
            padding: 2px 5px; /* 狭く */
            border-radius: 9999px;
            transition: all 0.2s ease-in-out;
            font-size: 0.6rem; /* わずかに小さく */
            line-height: 1rem;
            border: 1px solid #e5e7eb; /* gray-200 */
            white-space: nowrap; /* 折り返しを防ぐ */
        }
        /* ラジオボタンの input 要素は CSS で完全に非表示 */
        .location-radio-group input[type="radio"] {
            display: none;
        }
        /* hidden クラスが適用された要素を完全に非表示にする */
        .location-radio-group input[type="radio"].hidden,
        .location-radio-group label.hidden {
            display: none !important;
        }

        .location-radio-group input[type="radio"]:checked + label {
            color: white;
        }
        /* 各場所に応じた色設定 */
        .location-radio-group input[type="radio"][value="hand"]:checked + label { background-color: #3b82f6; border-color: #2563eb; } /* blue-500 */
        .location-radio-group input[type="radio"][value="stage"]:checked + label { background-color: #ef4444; border-color: #dc2626; } /* red-500 */
        .location-radio-group input[type="radio"][value="waiting"]:checked + label { background-color: #6b7280; border-color: #4b5563; } /* gray-500 */
        .location-radio-group input[type="radio"][value="stock"]:checked + label { background-color: #f59e0b; border-color: #d97706; } /* amber-500 */
        .location-radio-group input[type="radio"][value="clock"]:checked + label { background-color: #8b5cf6; border-color: #7c3aed; } /* violet-500 */
        .location-radio-group input[type="radio"][value="level"]:checked + label { background-color: #ec4899; border-color: #db2777; } /* pink-500 */
        .location-radio-group input[type="radio"][value="deck"]:checked + label { background-color: #10b981; border-color: #059669; } /* emerald-500 */
        .location-radio-group input[type="radio"][value="exile"]:checked + label { background-color: #06b6d4; border-color: #0891b5; } /* cyan-500 */


        /* レイアウト修正用CSS */
        .card-info-box {
            display: flex;
            align-items: center;
            flex-shrink: 0;
            margin-right: 0.5rem; 
            min-width: 0;
            /* ドラッグハンドル */
            cursor: grab;
        }
        .card-info-box:active {
            cursor: grabbing;
        }
        
        .card-name-text {
            font-size: 0.875rem; /* text-sm */
            font-weight: 500; /* font-medium */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.25rem;
        }
        /* 小画面でボタンがはみ出た場合にスクロールさせる */
        .location-radio-group {
            overflow-x: auto;
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        .location-radio-group::-webkit-scrollbar {
            display: none; /* Chrome, Safari, and Opera */
        }
        
        /* ドラッグ中のスタイル */
        .sortable-ghost {
            opacity: 0.4;
            background: #c0e1ff;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        <header class="mb-6">
            <h1 class="text-2xl sm:text-3xl font-bold text-gray-900">ヴァイス 一人回しツール</h1>
            <p class="text-sm text-gray-600 mt-1">WS用</p>
        </header>

        <!-- 各種ボタン -->
        <div class="mb-4 flex justify-end gap-2">
            <button id="settings-button" class="p-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg shadow-md transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0L8.21 5.15c-.5.42-1.13.71-1.84.71H4.22c-1.66 0-2.45 2.03-1.03 3.06l1.2 1.03c.54.46.82 1.14.68 1.83l-.4 1.94c-.46 2.23 2.09 3.89 4.07 2.61l1.72-1.09c.64-.41 1.44-.41 2.08 0l1.72 1.09c1.98 1.28 4.53-.38 4.07-2.61l-.4-1.94c-.14-.69.14-1.37.68-1.83l1.2-1.03c1.42-1.03.63-3.06-1.03-3.06h-2.15c-.71 0-1.34-.29-1.84-.71L11.49 3.17zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" />
                </svg>
            </button>
            <button id="shuffle-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-1.5 px-3 text-sm rounded-lg shadow-md transition-colors">
                山札シャッフル
            </button>
            <button id="reset-button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-1.5 px-3 text-sm rounded-lg shadow-md transition-colors">
                リセット
            </button>
        </div>

        <!-- 操作パネル (Sticky Header) -->
        <div class="bg-white p-4 rounded-lg shadow-md sticky top-0 z-10">
            <div class="flex flex-wrap items-center gap-2 sm:gap-4 mb-4">
                <button id="draw-button" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-1.5 px-3 text-sm rounded-lg transition-colors">draw</button>
                <button id="sort-hand-button" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-1.5 px-3 text-sm rounded-lg transition-colors">sort</button>
                <button id="damage-2-button" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-1.5 px-3 text-sm rounded-lg transition-colors" data-damage="2">2</button>
                <button id="damage-3-button" class="bg-purple-700 hover:bg-purple-800 text-white font-bold py-1.5 px-3 text-sm rounded-lg transition-colors" data-damage="3">3</button>
                <button id="level-up-button" class="bg-pink-600 hover:bg-pink-700 text-white font-bold py-1.5 px-3 text-sm rounded-lg transition-colors">Lv</button>
                <button id="refresh-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-1.5 px-3 text-sm rounded-lg transition-colors">Ref</button>
            </div>
            <!-- カウンター -->
            <div id="counters" class="grid grid-cols-4 sm:grid-cols-5 md:grid-cols-8 gap-1 sm:gap-2 text-center">
                <div class="bg-blue-100 text-blue-800 p-1 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:shadow-lg transition-shadow" data-location="hand"><div class="text-xs font-medium">手札</div><span id="count-hand" class="text-base font-bold">0</span></div>
                <div class="bg-red-100 text-red-800 p-1 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:shadow-lg transition-shadow" data-location="stage"><div class="text-xs font-medium">舞台</div><span id="count-stage" class="text-base font-bold">0</span></div>
                <div class="bg-gray-200 text-gray-800 p-1 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:shadow-lg transition-shadow" data-location="waiting"><div class="text-xs font-medium">控室</div><span id="count-waiting" class="text-base font-bold">0</span></div>
                <div class="bg-amber-100 text-amber-800 p-1 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:shadow-lg transition-shadow" data-location="stock"><div class="text-xs font-medium">ストック</div><span id="count-stock" class="text-base font-bold">0</span></div>
                <div class="bg-violet-100 text-violet-800 p-1 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:shadow-lg transition-shadow" data-location="clock"><div class="text-xs font-medium">クロック</div><span id="count-clock" class="text-base font-bold">0</span></div>
                <div class="bg-pink-100 text-pink-800 p-1 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:shadow-lg transition-shadow" data-location="level"><div class="text-xs font-medium">レベル</div><span id="count-level" class="text-base font-bold">0</span></div>
                <div class="bg-emerald-100 text-emerald-800 p-1 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:shadow-lg transition-shadow" data-location="deck"><div class="text-xs font-medium">山札</div><span id="count-deck" class="text-base font-bold">0</span></div>
                <!-- 追放領域カウンター - JavaScriptでhiddenクラスを制御 -->
                <div class="bg-cyan-100 text-cyan-800 p-1 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:shadow-lg transition-shadow" data-location="exile"><div class="text-xs font-medium">追放</div><span id="count-exile" class="text-base font-bold">0</span></div>
            </div>
        </div>
        
        <div id="status-message" class="hidden p-3 mb-4 rounded-lg font-semibold transition-opacity duration-300"></div>
        <div id="deck-list-container" class="bg-white rounded-lg shadow-md overflow-hidden mb-6"></div>
        <div class="bg-white p-4 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold mb-2">デッキリスト入力</h2>
            <p class="text-sm text-gray-600 mb-2">
                以下の形式(ヘッダー行を含む)でデッキリストを貼り付けて、「デッキを読み込む」ボタンを押してください。<br>
                <code class="text-xs bg-gray-200 p-1 rounded">カード番号,枚数,カード名,レベル,コスト,種類</code>
            </p>
            <textarea id="deck-input" class="w-full h-40 p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500" placeholder="ここにデッキリスト(CSV形式)を貼り付け..."></textarea>
            <button id="load-deck-button" class="mt-2 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                デッキを読み込む
            </button>
        </div>
    </div>

    <!-- カードモーダル -->
    <div id="card-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg shadow-2xl w-11/12 max-w-lg max-h-[90vh] overflow-y-auto transform transition-all">
            <div class="flex justify-between items-center border-b pb-3 mb-4">
                <h3 id="modal-title" class="text-xl font-bold text-gray-800">カードリスト</h3>
                <button id="close-card-modal" class="text-gray-500 hover:text-gray-800 text-2xl font-semibold leading-none">&times;</button>
            </div>
            <div id="modal-content" class="space-y-2"></div>
            <div class="mt-4 text-sm text-gray-600">※このリストの順番は、ゲーム内の配置順とは必ずしも一致しません。</div>
        </div>
    </div>
    
    <!-- 設定モーダル -->
    <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg shadow-2xl w-11/12 max-w-md">
             <div class="flex justify-between items-center border-b pb-3 mb-4">
                <h3 class="text-xl font-bold text-gray-800">設定</h3>
                <button id="close-settings-modal" class="text-gray-500 hover:text-gray-800 text-2xl font-semibold leading-none">&times;</button>
            </div>
            <div class="space-y-4">
                <div class="flex items-center">
                    <input type="checkbox" id="show-exile-toggle" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="show-exile-toggle" class="ml-3 block text-sm font-medium text-gray-700">「追放」領域を表示する</label>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 画像拡大表示用モーダル -->
    <div id="image-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center z-[60]">
        <div class="relative p-4">
            <button id="close-image-modal" class="absolute -top-2 -right-2 bg-white rounded-full p-1 shadow-lg text-gray-800 hover:text-red-500 z-10">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            <img id="image-modal-content" src="" alt="カード画像" class="max-w-[80vw] max-h-[80vh] rounded-lg shadow-xl">
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // デフォルトデッキデータを更新
            const deckDataCSV = `カード番号,枚数,カード名,レベル,コスト,種類
KMS/W133-003,2,のびやかな女の子 カレン,3,2,キャラ
KMS/W133-004b,4,15th Anniversary アリス,3,2,キャラ
KMS/W133-017,1,渾身の決めポーズ カレン,2,1,キャラ
KMS/W133-043,1,おしゃれな洋服 忍,2,1,キャラ
KMS/W133-002b,4,15th Anniversary カレン,1,0,キャラ
KMS/W133-008,4,ちっちゃくたって アリス,1,0,キャラ
KMS/W133-016,4,名探偵 カレン,1,0,キャラ
KMS/W133-037,3,軽いスキンシップ 忍＆カレン,1,0,キャラ
KMS/W133-001,3,すこやかな女の子 アリス,0,0,キャラ
KMS/W133-006,4,2人の金髪少女 アリス＆カレン,0,0,キャラ
KMS/W133-035,2,夏の装い 忍,0,0,キャラ
KMS/W133-036,4,頼れるお姉ちゃん 勇,0,0,キャラ
KMS/W133-055,4,15th Anniversary 陽子,0,0,キャラ
KMS/W133-082,2,家庭科教師 久世橋先生,0,0,キャラ
KMS/W133-029,4,みんなからの人気者,0,0,クライマックス
KMS/W133-030,4,金髪の天使,0,0,クライマックス`;

            const locations = [
                { id: 'hand', name: '手札' }, { id: 'stage', name: '舞台' },
                { id: 'waiting', name: '控室' }, { id: 'stock', name: 'スト' },
                { id: 'clock', name: 'クロ' }, { id: 'level', name: 'レベ' },
                { id: 'deck', name: '山札' }, { id: 'exile', name: '追放' }
            ];

            let fullDeck = [];
            const deckListContainer = document.getElementById('deck-list-container');
            const shuffleButton = document.getElementById('shuffle-button');
            const drawButton = document.getElementById('draw-button'); 
            const resetButton = document.getElementById('reset-button'); 
            const loadDeckButton = document.getElementById('load-deck-button');
            const sortHandButton = document.getElementById('sort-hand-button'); 
            const levelUpButton = document.getElementById('level-up-button');
            const deckInput = document.getElementById('deck-input');
            const statusMessage = document.getElementById('status-message'); 
            
            // カードモーダル関連要素
            const cardModal = document.getElementById('card-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalContent = document.getElementById('modal-content');
            const closeCardModalButton = document.getElementById('close-card-modal');
            const counterElements = document.querySelectorAll('#counters > div[data-location]'); 
            
            // 画像拡大モーダル関連要素
            const imageModal = document.getElementById('image-modal');
            const imageModalContent = document.getElementById('image-modal-content');
            const closeImageModalButton = document.getElementById('close-image-modal');

            // 設定モーダル関連要素
            const settingsModal = document.getElementById('settings-modal');
            const settingsButton = document.getElementById('settings-button');
            const closeSettingsModalButton = document.getElementById('close-settings-modal');
            const showExileToggle = document.getElementById('show-exile-toggle');
            
            const refreshButton = document.getElementById('refresh-button');

            // --- Helper Functions ---
            
            function showStatus(message, type = 'info') {
                statusMessage.textContent = message;
                statusMessage.classList.remove('hidden', 'bg-green-100', 'text-green-800', 'bg-red-100', 'text-red-800', 'bg-yellow-100', 'text-yellow-800');
                statusMessage.classList.add('opacity-100');
                if (type === 'success') statusMessage.classList.add('bg-green-100', 'text-green-800');
                else if (type === 'error') statusMessage.classList.add('bg-red-100', 'text-red-800');
                else statusMessage.classList.add('bg-yellow-100', 'text-yellow-800');
                setTimeout(() => { statusMessage.classList.remove('opacity-100'); statusMessage.classList.add('hidden'); }, 5000);
            }
            
            function showImageModal(imageUrl) {
                if (!imageUrl || imageUrl === 'null') {
                     imageModalContent.src = 'https://placehold.co/400x559/cccccc/000000?text=NO+IMAGE';
                } else {
                     imageModalContent.src = imageUrl;
                }
                imageModal.classList.remove('hidden');
                imageModal.classList.add('flex');
            }
            
            function closeImageModal() {
                imageModal.classList.add('hidden');
                imageModal.classList.remove('flex');
                imageModalContent.src = '';
            }
            
            window.showImageModal = showImageModal;

            function isImageCardSupported(cardCode) {
                if (!cardCode) return false;
                return cardCode.startsWith('UMA/') || 
                       cardCode.startsWith('GIM/') || 
                       cardCode.startsWith('YRC/') ||
                       cardCode.startsWith('KMS/') ||
                       cardCode.includes('/W62-') ||
                       cardCode.includes('/W123-');
            }
            
            function createCardImageUrl(cardCode) {
                if (!isImageCardSupported(cardCode)) return null;
                const parts = cardCode.split('/'); 
                if (parts.length < 2) return null;
                const seriesPrefix = parts[0].toLowerCase();
                const fullCardId = parts[1]; 
                let subDirectoryChar = seriesPrefix.charAt(0).toLowerCase();
                if (!fullCardId.includes('-')) return null;
                const idParts = fullCardId.split('-'); 
                if (idParts.length < 2) return null; 
                const setCode = idParts[0].toLowerCase();
                const cardSuffix = idParts[1].toLowerCase(); 
                let directoryName = "";
                if (setCode === 'w123') directoryName = 'sxx_w123';
                else directoryName = seriesPrefix + "_" + setCode;
                const fileName = seriesPrefix + "_" + setCode + "_" + cardSuffix + ".png";
                const baseUrl = 'https://ws-tcg.com/wordpress/wp-content/images/cardlist/';
                return baseUrl + subDirectoryChar + '/' + directoryName + '/' + fileName;
            }

            // --- LocalStorage & Settings ---
            
            function toggleExileVisibility(show) {
                const exileCounter = document.querySelector('div[data-location="exile"]');
                if (exileCounter) exileCounter.classList.toggle('hidden', !show);
                document.querySelectorAll('input[value="exile"]').forEach(input => {
                    input.classList.toggle('hidden', !show); 
                    const label = document.querySelector(`label[for="${input.id}"]`);
                    if (label) label.classList.toggle('hidden', !show);
                });
            }

            function saveState() {
                const cardLocations = [];
                const cardOrder = []; 
                
                Array.from(deckListContainer.children).forEach(row => {
                    const cardId = row.dataset.cardId;
                    cardOrder.push(cardId); 
                    
                    const checkedRadio = row.querySelector('input[type="radio"]:checked');
                    if (checkedRadio) {
                        cardLocations.push({
                            id: cardId,
                            location: checkedRadio.value
                        });
                    }
                });

                const state = {
                    deckCsv: deckInput.value,
                    cardLocations: cardLocations,
                    showExile: showExileToggle.checked,
                    cardOrder: cardOrder 
                };
                
                try { localStorage.setItem('wsToolState', JSON.stringify(state)); } 
                catch (e) { console.error("Could not save state:", e); }
            }

            function loadState() {
                try {
                    const savedState = localStorage.getItem('wsToolState');
                    if (!savedState) return false; 
                    const state = JSON.parse(savedState);
                    const showExile = state.showExile === true;
                    showExileToggle.checked = showExile;
                    deckInput.value = state.deckCsv || deckDataCSV.trim();
                    
                    loadDeckFromTextarea(false); 
                    toggleExileVisibility(showExile); 

                    if (state.cardOrder && state.cardOrder.length > 0) {
                        const cardMap = new Map();
                        Array.from(deckListContainer.children).forEach(row => cardMap.set(row.dataset.cardId, row));
                        
                        deckListContainer.innerHTML = ''; 
                        
                        state.cardOrder.forEach(cardId => {
                            const row = cardMap.get(cardId);
                            if (row) {
                                deckListContainer.appendChild(row);
                                cardMap.delete(cardId); 
                            }
                        });
                        
                        cardMap.forEach(row => deckListContainer.appendChild(row));
                    }

                    if (state.cardLocations?.length > 0) {
                        const locationMap = new Map(state.cardLocations.map(cl => [cl.id.toString(), cl.location]));
                        Array.from(deckListContainer.children).forEach(row => {
                            const savedLocation = locationMap.get(row.dataset.cardId);
                            if (savedLocation) {
                                const targetRadio = row.querySelector(`input[value="${savedLocation}"]`);
                                if (savedLocation === 'exile' && !showExile) {
                                    row.querySelector('input[value="deck"]').checked = true;
                                } else if (targetRadio) {
                                    targetRadio.checked = true;
                                }
                            }
                        });
                        updateCounters();
                        showStatus('前回終了時の状態を復元しました。', 'info');
                        return true;
                    }
                } catch (e) { console.error("Error loading state:", e); }
                return false;
            }

            // --- Core Functions ---
            function parseDeckData(csv) {
                try {
                    const lines = csv.trim().split('\n').slice(1); 
                    const deck = [];
                    let cardId = 0;
                    lines.forEach((line, index) => {
                        const parts = line.split(',');
                        if (parts.length < 6) return; 
                        const [cardCode, countStr, name, level, cost, type] = parts;
                        const count = parseInt(countStr, 10);
                        if (isNaN(count) || count <= 0) return;
                        for (let i = 0; i < count; i++) {
                            deck.push({ id: cardId++, cardCode: cardCode.trim(), name: name.trim(), level: level.trim(), type: type.trim() });
                        }
                    });
                    return deck;
                } catch (error) { console.error("Error parsing deck data:", error); return []; }
            }

            function renderDeck(deck) {
                deckListContainer.innerHTML = ''; 
                deck.forEach(card => {
                    const cardRow = document.createElement('div');
                    cardRow.className = 'flex items-center justify-between py-1.5 px-3 border-b border-gray-200 last:border-b-0';
                    ['cardId', 'cardCode', 'cardName', 'cardLevel', 'cardType'].forEach(attr => cardRow.dataset[attr] = card[attr.replace('card', '').toLowerCase()]);
                    
                    const cardInfo = document.createElement('div');
                    cardInfo.className = 'card-info-box text-sm'; 
                    const isImageCard = isImageCardSupported(card.cardCode);

                    if (isImageCard) {
                        const imageUrl = createCardImageUrl(card.cardCode);
                        cardInfo.innerHTML = `
                            <div class="w-10 h-10 overflow-hidden rounded-md border border-gray-300 shadow flex-shrink-0 cursor-pointer" title="${card.name} (Lv ${card.level})" onclick="showImageModal('${imageUrl}')">
                                <img src="${imageUrl}" alt="${card.name}" class="w-full h-full object-cover" onerror="this.onerror=null; this.src='https://placehold.co/40x40/cccccc/000000?text=Card';">
                            </div>
                            <span class="hidden sm:inline font-medium text-sm ml-2 truncate" title="${card.name}">${card.name}</span>
                        `;
                    } else {
                        const levelText = card.type === 'クライマックス' ? 'CX' : card.level;
                        cardInfo.innerHTML = `<div class="flex items-center w-full"><span class="font-bold text-gray-700 w-3 inline-block text-center mr-2 flex-shrink-0">${levelText}</span> <span class="card-name-text">${card.name}</span></div>`;
                    }

                    const locationGroup = document.createElement('div');
                    locationGroup.className = 'flex flex-nowrap gap-x-2 gap-y-1 location-radio-group';
                    locations.forEach(loc => {
                        const radioId = `card-${card.id}-loc-${loc.id}`;
                        locationGroup.innerHTML += `<input type="radio" id="${radioId}" name="card-location-${card.id}" value="${loc.id}" ${loc.id === 'deck' ? 'checked' : ''}><label for="${radioId}">${loc.name}</label>`;
                    });

                    cardRow.appendChild(cardInfo);
                    cardRow.appendChild(locationGroup);
                    deckListContainer.appendChild(cardRow);
                });
            }

            function updateCounters() {
                const counts = locations.reduce((acc, loc) => ({ ...acc, [loc.id]: 0 }), {});
                document.querySelectorAll('input[type="radio"]:checked').forEach(radio => counts[radio.value]++);
                locations.forEach(loc => document.getElementById(`count-${loc.id}`).textContent = counts[loc.id]);
                saveState();
            }
            
            function resetDeck() {
                let allRows = Array.from(deckListContainer.children);
                allRows.forEach(row => {
                    const deckRadio = row.querySelector('input[value="deck"]');
                    if (deckRadio) deckRadio.checked = true;
                });
                for (let i = allRows.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allRows[i], allRows[j]] = [allRows[j], allRows[i]];
                }
                deckListContainer.innerHTML = '';
                allRows.forEach(node => deckListContainer.appendChild(node));
                const initialHandElements = Array.from(deckListContainer.children).slice(0, 5); 
                initialHandElements.forEach(cardRow => {
                    const handRadio = cardRow.querySelector('input[value="hand"]');
                    if (handRadio) handRadio.checked = true;
                });
                updateCounters();
                saveState(); 
                showStatus('ゲームを初期化し、山札をシャッフル、上から5枚を手札にしました。', 'success');
            }

            function shuffleDeck() {
                const deckListRows = Array.from(deckListContainer.children);
                let deckNodes = deckListRows.filter(row => row.querySelector('input[value="deck"]:checked'));
                let otherNodes = deckListRows.filter(row => !row.querySelector('input[value="deck"]:checked'));
                for (let i = deckNodes.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deckNodes[i], deckNodes[j]] = [deckNodes[j], deckNodes[i]];
                }
                deckListContainer.innerHTML = '';
                otherNodes.forEach(node => deckListContainer.appendChild(node));
                deckNodes.forEach(node => deckListContainer.appendChild(node));
                updateCounters();
                saveState(); 
                showStatus('山札のカードのみをシャッフルしました。', 'success');
            }
            
            function loadDeckFromTextarea(shouldSave = true) {
                const csvData = deckInput.value;
                if (!csvData.trim()) return showStatus('デッキリストが入力されていません。', 'error');
                fullDeck = parseDeckData(csvData);
                if (fullDeck.length === 0) return showStatus('デッキリストの解析に失敗しました。', 'error');
                renderDeck(fullDeck);
                toggleExileVisibility(showExileToggle.checked);
                updateCounters();
                if (shouldSave) {
                    saveState(); 
                    showStatus(`デッキを読み込みました (合計 ${fullDeck.length} 枚)。`, 'success');
                }
            }

            function getLevelSortValue(card) {
                return card.type === 'クライマックス' ? 99 : parseInt(card.level, 10);
            }

            function sortHandToTop() {
                const allRows = Array.from(deckListContainer.children);
                const locationGroups = locations.reduce((acc, loc) => ({ ...acc, [loc.id]: [] }), {});
                allRows.forEach(row => {
                    const location = row.querySelector('input[type="radio"]:checked').value;
                    if (locationGroups[location]) locationGroups[location].push(row);
                });
                locationGroups.hand.sort((a, b) => getLevelSortValue({ level: a.dataset.cardLevel, type: a.dataset.cardType }) - getLevelSortValue({ level: b.dataset.cardLevel, type: b.dataset.cardType }));
                const sortedRows = locations.flatMap(loc => locationGroups[loc.id] || []);
                deckListContainer.innerHTML = '';
                sortedRows.forEach(node => deckListContainer.appendChild(node));
                saveState();
                showStatus('全てのカードを場所順に並び替え、手札のみレベル順でソートしました。', 'success');
            }

            function drawCard() {
                const topCardRow = Array.from(deckListContainer.children).find(row => row.querySelector('input[value="deck"]:checked'));
                if (!topCardRow) return showStatus('山札にカードがありません。', 'error');
                const handRadio = topCardRow.querySelector('input[value="hand"]');
                if (handRadio) handRadio.checked = true;
                updateCounters();
                showStatus(`${topCardRow.dataset.cardName} をドローしました。`, 'info');
            }

            function processDamage(damage) {
                const deckCards = Array.from(deckListContainer.children).filter(row => row.querySelector('input[value="deck"]:checked'));
                if (deckCards.length === 0) return showStatus('山札がありません。', 'error');
                let flippedCards = [], isCanceled = false;
                const maxFlip = Math.min(damage, deckCards.length);
                for (let i = 0; i < maxFlip; i++) {
                    flippedCards.push(deckCards[i]);
                    if (deckCards[i].dataset.cardType === 'クライマックス') { isCanceled = true; break; }
                }
                let targetLocation = isCanceled ? 'waiting' : 'clock';
                flippedCards.forEach(cardRow => {
                    const targetRadio = cardRow.querySelector(`input[value="${targetLocation}"]`);
                    if (targetRadio) targetRadio.checked = true;
                });
                updateCounters();
                let message = `${damage}点ダメージ！ ${flippedCards.length}枚目でCXが${isCanceled ? '出てキャンセル' : '出ず通りました'}。`;
                showStatus(message, isCanceled ? 'success' : 'error');
            }

            function levelUp() {
                const clockCards = Array.from(deckListContainer.children).filter(row => row.querySelector('input[value="clock"]:checked'));
                if (clockCards.length < 6) return showStatus(`クロックが6枚未満です。`, 'error');
                const cardsToMove = clockCards.slice(0, 6);
                cardsToMove.forEach(cardRow => {
                    const waitingRadio = cardRow.querySelector(`input[value="waiting"]`);
                    if (waitingRadio) waitingRadio.checked = true;
                });
                updateCounters(); 
                showStatus(`クロックの上から6枚を控え室に送りました。`, 'success');
            }

            function refreshDeck() {
                const waitingCards = Array.from(deckListContainer.children).filter(row =>
                    row.querySelector('input[value="waiting"]:checked')
                );

                if (waitingCards.length === 0) {
                    showStatus("控室にカードがありません。", "info");
                    return;
                }

                waitingCards.forEach(cardRow => {
                    const deckRadio = cardRow.querySelector('input[value="deck"]');
                    if (deckRadio) {
                        deckRadio.checked = true;
                    }
                });

                updateCounters(); 
                showStatus(`控室の ${waitingCards.length} 枚のカードを山札に戻しました。`, 'success');
            }
            
            function showCardModal(locationId) {
                const locationName = locations.find(loc => loc.id === locationId)?.name || locationId;
                modalTitle.textContent = `${locationName} のカード一覧`;
                modalContent.innerHTML = ''; 
                
                const targetCards = Array.from(deckListContainer.children).filter(row => row.querySelector(`input[value="${locationId}"]:checked`));
                
                if (targetCards.length === 0) {
                    modalContent.className = 'space-y-2'; 
                    modalContent.innerHTML = '<p class="text-gray-500">この場所には現在カードがありません。</p>';
                } else {
                    const isImageMode = targetCards.length > 0 && isImageCardSupported(targetCards[0].dataset.cardCode);
                    
                    if (isImageMode) {
                        modalContent.className = 'flex flex-wrap gap-2 justify-center';
                    } else {
                        modalContent.className = 'space-y-2';
                    }

                    targetCards.forEach(cardRow => {
                        const { cardName, cardLevel, cardType, cardCode } = cardRow.dataset;
                        const cardElement = document.createElement('div');
                        const isImageCard = isImageCardSupported(cardCode);
                        
                        if (isImageCard) {
                            const imageUrl = createCardImageUrl(cardCode);
                            cardElement.className = 'flex items-center justify-center';
                            cardElement.innerHTML = `
                                <div class="w-20 h-20 overflow-hidden rounded-md border border-gray-300 shadow cursor-pointer" title="${cardName} (Lv ${cardLevel})" onclick="showImageModal('${imageUrl}')">
                                    <img src="${imageUrl}" alt="${cardName}" class="w-full h-full object-cover" onerror="this.onerror=null; this.src='https://placehold.co/80x80/cccccc/000000?text=Card';">
                                </div>
                            `;
                        } else {
                            const levelText = cardType === 'クライマックス' ? 'CX' : cardLevel;
                            cardElement.className = 'p-3 bg-white border border-gray-200 rounded-lg shadow-sm text-sm flex items-center w-full';
                            cardElement.innerHTML = `
                                <span class="font-bold text-gray-700 w-4 inline-block text-center mr-3 text-lg flex-shrink-0">${levelText}</span> 
                                <span class="font-semibold text-gray-800 text-base">${cardName}</span>
                            `;
                        }
                        modalContent.appendChild(cardElement);
                    });
                }
                cardModal.classList.remove('hidden'); cardModal.classList.add('flex');
            }

            function closeModal(modalElement) { modalElement.classList.add('hidden'); modalElement.classList.remove('flex'); }

            // --- Event Listeners ---
            loadDeckButton.addEventListener('click', () => loadDeckFromTextarea(true)); 
            shuffleButton.addEventListener('click', shuffleDeck);
            resetButton.addEventListener('click', resetDeck); 
            drawButton.addEventListener('click', drawCard); 
            sortHandButton.addEventListener('click', sortHandToTop); 
            levelUpButton.addEventListener('click', levelUp);
            refreshButton.addEventListener('click', refreshDeck); 
            document.getElementById('damage-2-button').addEventListener('click', (e) => processDamage(parseInt(e.target.dataset.damage)));
            document.getElementById('damage-3-button').addEventListener('click', (e) => processDamage(parseInt(e.target.dataset.damage)));
            deckListContainer.addEventListener('change', (event) => { if (event.target.type === 'radio') updateCounters(); });
            counterElements.forEach(counter => counter.addEventListener('click', () => showCardModal(counter.dataset.location)));
            
            // Modal Listeners
            closeCardModalButton.addEventListener('click', () => closeModal(cardModal));
            cardModal.addEventListener('click', (e) => { if (e.target === cardModal) closeModal(cardModal); });
            
            closeImageModalButton.addEventListener('click', closeImageModal);
            imageModal.addEventListener('click', (e) => {
                if (e.target === imageModal) {
                    closeImageModal();
                }
            });

            // Settings Modal Listeners
            settingsButton.addEventListener('click', () => { settingsModal.classList.remove('hidden'); settingsModal.classList.add('flex'); });
            closeSettingsModalButton.addEventListener('click', () => closeModal(settingsModal));
            settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) closeModal(settingsModal); });
            
            showExileToggle.addEventListener('change', (e) => {
                toggleExileVisibility(e.target.checked);
                saveState(); 
            });
            
            // SortableJS Initialization
            new Sortable(deckListContainer, {
                animation: 150,
                ghostClass: 'sortable-ghost',
                chosenClass: 'sortable-chosen',
                handle: '.card-info-box',
                onEnd: function (evt) {
                    saveState();
                }
            });

            // --- Initialization ---
            if (!loadState()) {
                deckInput.value = deckDataCSV.trim();
                loadDeckFromTextarea(false); 
                resetDeck(); 
            }
        });
    </script>
</body>
</html>
