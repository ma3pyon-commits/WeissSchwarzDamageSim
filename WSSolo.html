<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WSSolo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
        }
        /* カスタムラジオボタンのスタイル（狭く表示するための調整） */
        .location-radio-group label {
            cursor: pointer;
            padding: 2px 5px; /* 狭く */
            border-radius: 9999px;
            transition: all 0.2s ease-in-out;
            font-size: 0.6rem; /* わずかに小さく */
            line-height: 1rem;
            border: 1px solid #e5e7eb; /* gray-200 */
            white-space: nowrap; /* 折り返しを防ぐ */
        }
        /* ラジオボタンの input 要素は CSS で完全に非表示 */
        .location-radio-group input[type="radio"] {
            display: none;
        }
        /* hidden クラスが適用された要素を完全に非表示にする */
        .location-radio-group input[type="radio"].hidden,
        .location-radio-group label.hidden {
            display: none !important;
        }

        .location-radio-group input[type="radio"]:checked + label {
            color: white;
        }
        /* 各場所に応じた色設定 */
        .location-radio-group input[type="radio"][value="hand"]:checked + label { background-color: #3b82f6; border-color: #2563eb; } /* blue-500 */
        .location-radio-group input[type="radio"][value="stage"]:checked + label { background-color: #ef4444; border-color: #dc2626; } /* red-500 */
        .location-radio-group input[type="radio"][value="waiting"]:checked + label { background-color: #6b7280; border-color: #4b5563; } /* gray-500 */
        .location-radio-group input[type="radio"][value="stock"]:checked + label { background-color: #f59e0b; border-color: #d97706; } /* amber-500 */
        .location-radio-group input[type="radio"][value="clock"]:checked + label { background-color: #8b5cf6; border-color: #7c3aed; } /* violet-500 */
        .location-radio-group input[type="radio"][value="level"]:checked + label { background-color: #ec4899; border-color: #db2777; } /* pink-500 */
        .location-radio-group input[type="radio"][value="deck"]:checked + label { background-color: #10b981; border-color: #059669; } /* emerald-500 */
        .location-radio-group input[type="radio"][value="exile"]:checked + label { background-color: #06b6d4; border-color: #0891b5; } /* cyan-500 */


        /* レイアウト修正用CSS */
        .card-info-box {
            /* カード情報全体を格納するボックス */
            display: flex;
            align-items: center;
            flex-shrink: 0;
            /* 修正点: 右マージンを最小限に設定 (空欄を詰める) */
            margin-right: 0.5rem; 
            min-width: 0; /* flexアイテムが縮むのを許可 */
        }
        .card-name-text {
            /* 画像がない場合に表示するカード名テキストのスタイル */
            font-size: 0.875rem; /* text-sm */
            font-weight: 500; /* font-medium */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.25rem;
        }
        /* 小画面でボタンがはみ出た場合にスクロールさせる */
        .location-radio-group {
            overflow-x: auto;
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        .location-radio-group::-webkit-scrollbar {
            display: none; /* Chrome, Safari, and Opera */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        <header class="mb-6">
            <h1 class="text-2xl sm:text-3xl font-bold text-gray-900">ヴァイス 一人回しツール</h1>
            <p class="text-sm text-gray-600 mt-1">WS用</p>
        </header>

        <!-- 各種ボタン -->
        <div class="mb-4 flex justify-end gap-2">
            <button id="settings-button" class="p-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg shadow-md transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0L8.21 5.15c-.5.42-1.13.71-1.84.71H4.22c-1.66 0-2.45 2.03-1.03 3.06l1.2 1.03c.54.46.82 1.14.68 1.83l-.4 1.94c-.46 2.23 2.09 3.89 4.07 2.61l1.72-1.09c.64-.41 1.44-.41 2.08 0l1.72 1.09c1.98 1.28 4.53-.38 4.07-2.61l-.4-1.94c-.14-.69.14-1.37.68-1.83l1.2-1.03c1.42-1.03.63-3.06-1.03-3.06h-2.15c-.71 0-1.34-.29-1.84-.71L11.49 3.17zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" />
                </svg>
            </button>
            <button id="shuffle-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-1.5 px-3 text-sm rounded-lg shadow-md transition-colors">
                山札シャッフル
            </button>
            <button id="reset-button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-1.5 px-3 text-sm rounded-lg shadow-md transition-colors">
                リセット
            </button>
        </div>

        <!-- 操作パネル (Sticky Header) -->
        <div class="bg-white p-4 rounded-lg shadow-md sticky top-0 z-10">
            <div class="flex flex-wrap items-center gap-2 sm:gap-4 mb-4">
                <button id="draw-button" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-1.5 px-3 text-sm rounded-lg transition-colors">ドロー</button>
                <button id="sort-hand-button" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-1.5 px-3 text-sm rounded-lg transition-colors">ソート</button>
                <button id="damage-2-button" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-1.5 px-3 text-sm rounded-lg transition-colors" data-damage="2">2</button>
                <button id="damage-3-button" class="bg-purple-700 hover:bg-purple-800 text-white font-bold py-1.5 px-3 text-sm rounded-lg transition-colors" data-damage="3">3</button>
                <button id="level-up-button" class="bg-pink-600 hover:bg-pink-700 text-white font-bold py-1.5 px-3 text-sm rounded-lg transition-colors">レベル</button>
            </div>
            <!-- カウンター -->
            <div id="counters" class="grid grid-cols-4 sm:grid-cols-5 md:grid-cols-8 gap-1 sm:gap-2 text-center">
                <div class="bg-blue-100 text-blue-800 p-1 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:shadow-lg transition-shadow" data-location="hand"><div class="text-xs font-medium">手札</div><span id="count-hand" class="text-base font-bold">0</span></div>
                <div class="bg-red-100 text-red-800 p-1 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:shadow-lg transition-shadow" data-location="stage"><div class="text-xs font-medium">舞台</div><span id="count-stage" class="text-base font-bold">0</span></div>
                <div class="bg-gray-200 text-gray-800 p-1 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:shadow-lg transition-shadow" data-location="waiting"><div class="text-xs font-medium">控室</div><span id="count-waiting" class="text-base font-bold">0</span></div>
                <div class="bg-amber-100 text-amber-800 p-1 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:shadow-lg transition-shadow" data-location="stock"><div class="text-xs font-medium">ストック</div><span id="count-stock" class="text-base font-bold">0</span></div>
                <div class="bg-violet-100 text-violet-800 p-1 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:shadow-lg transition-shadow" data-location="clock"><div class="text-xs font-medium">クロック</div><span id="count-clock" class="text-base font-bold">0</span></div>
                <div class="bg-pink-100 text-pink-800 p-1 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:shadow-lg transition-shadow" data-location="level"><div class="text-xs font-medium">レベル</div><span id="count-level" class="text-base font-bold">0</span></div>
                <div class="bg-emerald-100 text-emerald-800 p-1 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:shadow-lg transition-shadow" data-location="deck"><div class="text-xs font-medium">山札</div><span id="count-deck" class="text-base font-bold">0</span></div>
                <!-- 追放領域カウンター - JavaScriptでhiddenクラスを制御 -->
                <div class="bg-cyan-100 text-cyan-800 p-1 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:shadow-lg transition-shadow" data-location="exile"><div class="text-xs font-medium">追放</div><span id="count-exile" class="text-base font-bold">0</span></div>
            </div>
        </div>
        
        <div id="status-message" class="hidden p-3 mb-4 rounded-lg font-semibold transition-opacity duration-300"></div>
        <div id="deck-list-container" class="bg-white rounded-lg shadow-md overflow-hidden mb-6"></div>
        <div class="bg-white p-4 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold mb-2">デッキリスト入力</h2>
            <p class="text-sm text-gray-600 mb-2">
                以下の形式(ヘッダー行を含む)でデッキリストを貼り付けて、「デッキを読み込む」ボタンを押してください。<br>
                <code class="text-xs bg-gray-200 p-1 rounded">カード番号,枚数,カード名,レベル,コスト,種類</code>
            </p>
            <textarea id="deck-input" class="w-full h-40 p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500" placeholder="ここにデッキリスト(CSV形式)を貼り付け..."></textarea>
            <button id="load-deck-button" class="mt-2 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                デッキを読み込む
            </button>
        </div>
    </div>

    <!-- カードモーダル -->
    <div id="card-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg shadow-2xl w-11/12 max-w-lg max-h-[90vh] overflow-y-auto transform transition-all">
            <div class="flex justify-between items-center border-b pb-3 mb-4">
                <h3 id="modal-title" class="text-xl font-bold text-gray-800">カードリスト</h3>
                <button id="close-card-modal" class="text-gray-500 hover:text-gray-800 text-2xl font-semibold leading-none">&times;</button>
            </div>
            <div id="modal-content" class="space-y-2"></div>
            <div class="mt-4 text-sm text-gray-600">※このリストの順番は、ゲーム内の配置順とは必ずしも一致しません。</div>
        </div>
    </div>
    
    <!-- 設定モーダル -->
    <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg shadow-2xl w-11/12 max-w-md">
             <div class="flex justify-between items-center border-b pb-3 mb-4">
                <h3 class="text-xl font-bold text-gray-800">設定</h3>
                <button id="close-settings-modal" class="text-gray-500 hover:text-gray-800 text-2xl font-semibold leading-none">&times;</button>
            </div>
            <div class="space-y-4">
                <div class="flex items-center">
                    <input type="checkbox" id="show-exile-toggle" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="show-exile-toggle" class="ml-3 block text-sm font-medium text-gray-700">「追放」領域を表示する</label>
                </div>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // [修正] デフォルトデッキを 角川スニーカー文庫 に変更
            const deckDataCSV = `カード番号,枚数,カード名,レベル,コスト,種類
Shm/W123-075,1,発火少女 ホムラ,3,2,キャラ
Sks/W123-093,4,サマーバケーション めぐみん,3,2,キャラ
Snw/W62-083,1,第506統合戦闘航空団 ハインリーケ,3,2,キャラ
Srd/W123-021,1,修行の成果 綾乃,2,1,キャラ
Stm/W123-114,1,再会した、かつての親友 春希,2,1,キャラ
Sks/W123-010,4,冒険者（最弱職） カズマ,1,0,キャラ
Srd/W123-002,4,深窓のおひい様 有希,1,0,キャラ
Ssn/W123-001,4,ツン期の終わった元ツンデレ リット,1,0,キャラ
Shh/W123-117,1,アフターストーリー ハユル＆愛音＆傷無＆ユリシア,0,0,キャラ
Sks/W123-T10,4,35th Anniversary めぐみん,0,0,キャラ
Srd/W123-019,4,アドケナリン 有希,0,0,キャラ
Srd/W123-T11,1,思い出の場所 マーシャ,0,0,キャラ
Ssn/W123-004,1,幸せな日々 リット＆レッド,0,0,キャラ
Ssy/W123-007,2,親友 佐々木,0,0,キャラ
Ssy/W123-017,1,雑用係 キョン,0,0,キャラ
Ssy/W62-050,4,猪突猛進 ハルヒ,0,0,キャラ
Stk/W123-T09,1,35th Anniversary 結女,0,0,キャラ
Scn/W123-125,3,恋人旅行,3,1,イベント
Sks/W123-023,4,爆裂魔法,0,0,クライマックス
Srd/W123-024,4,可愛い妹による寝起きボディープレス,0,0,クライマックス`;

            const locations = [
                { id: 'hand', name: '手札' }, { id: 'stage', name: '舞台' },
                { id: 'waiting', name: '控室' }, { id: 'stock', name: 'スト' },
                { id: 'clock', name: 'クロ' }, { id: 'level', name: 'レベ' },
                { id: 'deck', name: '山札' }, { id: 'exile', name: '追放' }
            ];

            let fullDeck = [];
            const deckListContainer = document.getElementById('deck-list-container');
            const shuffleButton = document.getElementById('shuffle-button');
            const drawButton = document.getElementById('draw-button'); 
            const resetButton = document.getElementById('reset-button'); 
            const loadDeckButton = document.getElementById('load-deck-button');
            const sortHandButton = document.getElementById('sort-hand-button'); 
            const levelUpButton = document.getElementById('level-up-button');
            const deckInput = document.getElementById('deck-input');
            const statusMessage = document.getElementById('status-message'); 
            
            // モーダル関連要素
            const cardModal = document.getElementById('card-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalContent = document.getElementById('modal-content');
            const closeCardModalButton = document.getElementById('close-card-modal');
            const counterElements = document.querySelectorAll('#counters > div[data-location]'); 
            
            // 設定モーダル関連要素
            const settingsModal = document.getElementById('settings-modal');
            const settingsButton = document.getElementById('settings-button');
            const closeSettingsModalButton = document.getElementById('close-settings-modal');
            const showExileToggle = document.getElementById('show-exile-toggle');
            
            // --- Helper Functions ---
            
            function showStatus(message, type = 'info') {
                statusMessage.textContent = message;
                statusMessage.classList.remove('hidden', 'bg-green-100', 'text-green-800', 'bg-red-100', 'text-red-800', 'bg-yellow-100', 'text-yellow-800');
                statusMessage.classList.add('opacity-100');
                if (type === 'success') statusMessage.classList.add('bg-green-100', 'text-green-800');
                else if (type === 'error') statusMessage.classList.add('bg-red-100', 'text-red-800');
                else statusMessage.classList.add('bg-yellow-100', 'text-yellow-800');
                setTimeout(() => { statusMessage.classList.remove('opacity-100'); statusMessage.classList.add('hidden'); }, 5000);
            }
            
            function isImageCardSupported(cardCode) {
                if (!cardCode) return false;
                // [修正] W62, W123 を画像判定に追加
                return cardCode.startsWith('UMA/') || 
                       cardCode.startsWith('GIM/') || 
                       cardCode.startsWith('YRC/') ||
                       cardCode.includes('/W62-') ||  // スニーカー文庫 (旧)
                       cardCode.includes('/W123-'); // スニーカー文庫 (新)
            }
            
            function createCardImageUrl(cardCode) {
                if (!isImageCardSupported(cardCode)) return null;
                
                const parts = cardCode.split('/'); 
                if (parts.length < 2) return null;
                
                const seriesPrefix = parts[0].toLowerCase(); // "uma", "gim", "yrc", "ssy", "sks" etc.
                const fullCardId = parts[1]; 
                
                // サブディレクトリ文字 (u, g, y, s, etc.)
                let subDirectoryChar = seriesPrefix.charAt(0).toLowerCase();

                if (!fullCardId.includes('-')) return null;
                const idParts = fullCardId.split('-'); 
                if (idParts.length < 2) return null; 
                
                const setCode = idParts[0].toLowerCase(); // "w106", "w124", "w116", "w62", "w123"
                const cardSuffix = idParts[1].toLowerCase(); 
                
                let directoryName = "";
                
                // [修正] W123 (スニーカー文庫) の特別ルール
                if (setCode === 'w123') {
                    directoryName = 'sxx_w123'; // ユーザー指定の例外ルール
                } else {
                    directoryName = seriesPrefix + "_" + setCode;
                }
                
                const fileName = seriesPrefix + "_" + setCode + "_" + cardSuffix + ".png";
                const baseUrl = 'https://ws-tcg.com/wordpress/wp-content/images/cardlist/';
                
                return baseUrl + subDirectoryChar + '/' + directoryName + '/' + fileName;
            }

            // --- LocalStorage & Settings ---
            
            function toggleExileVisibility(show) {
                const exileCounter = document.querySelector('div[data-location="exile"]');
                if (exileCounter) exileCounter.classList.toggle('hidden', !show);

                document.querySelectorAll('input[value="exile"]').forEach(input => {
                    input.classList.toggle('hidden', !show); 
                    const label = document.querySelector(`label[for="${input.id}"]`);
                    if (label) label.classList.toggle('hidden', !show);
                });
            }

            function saveState() {
                const cardLocations = Array.from(deckListContainer.children).map(row => ({
                    id: row.dataset.cardId,
                    location: row.querySelector('input[type="radio"]:checked')?.value
                }));
                const state = {
                    deckCsv: deckInput.value,
                    cardLocations: cardLocations,
                    showExile: showExileToggle.checked
                };
                try { localStorage.setItem('wsToolState', JSON.stringify(state)); } 
                catch (e) { console.error("Could not save state:", e); }
            }

            function loadState() {
                try {
                    const savedState = localStorage.getItem('wsToolState');
                    if (!savedState) return false; 
                    const state = JSON.parse(savedState);
                    
                    const showExile = state.showExile === true;
                    showExileToggle.checked = showExile;

                    deckInput.value = state.deckCsv || deckDataCSV.trim();
                    loadDeckFromTextarea(false); // カードDOM生成

                    toggleExileVisibility(showExile); // 生成されたカードのラジオボタンとカウンターに適用
                    
                    if (state.cardLocations?.length > 0) {
                        const locationMap = new Map(state.cardLocations.map(cl => [cl.id.toString(), cl.location]));
                        Array.from(deckListContainer.children).forEach(row => {
                            const savedLocation = locationMap.get(row.dataset.cardId);
                            if (savedLocation) {
                                const targetRadio = row.querySelector(`input[value="${savedLocation}"]`);
                                if (savedLocation === 'exile' && !showExile) {
                                    row.querySelector('input[value="deck"]').checked = true;
                                } else if (targetRadio) {
                                    targetRadio.checked = true;
                                }
                            }
                        });
                        updateCounters();
                        showStatus('前回終了時の状態を復元しました。', 'info');
                        return true;
                    }
                } catch (e) { console.error("Error loading state:", e); }
                return false;
            }

            // --- Core Functions ---
            function parseDeckData(csv) {
                try {
                    const lines = csv.trim().split('\n').slice(1); 
                    const deck = [];
                    let cardId = 0;
                    lines.forEach((line, index) => {
                        const parts = line.split(',');
                        if (parts.length < 6) return; 
                        const [cardCode, countStr, name, level, cost, type] = parts;
                        const count = parseInt(countStr, 10);
                        if (isNaN(count) || count <= 0) return;
                        for (let i = 0; i < count; i++) {
                            deck.push({ id: cardId++, cardCode: cardCode.trim(), name: name.trim(), level: level.trim(), type: type.trim() });
                        }
                    });
                    return deck;
                } catch (error) { console.error("Error parsing deck data:", error); return []; }
            }

            function renderDeck(deck) {
                deckListContainer.innerHTML = ''; 
                deck.forEach(card => {
                    const cardRow = document.createElement('div');
                    cardRow.className = 'flex items-center justify-between py-1.5 px-3 border-b border-gray-200 last:border-b-0';
                    ['cardId', 'cardCode', 'cardName', 'cardLevel', 'cardType'].forEach(attr => cardRow.dataset[attr] = card[attr.replace('card', '').toLowerCase()]);
                    
                    const cardInfo = document.createElement('div');
                    cardInfo.className = 'card-info-box text-sm'; 
                    const isImageCard = isImageCardSupported(card.cardCode);

                    if (isImageCard) {
                        const imageUrl = createCardImageUrl(card.cardCode);
                        cardInfo.innerHTML = `
                            <div class="w-10 h-10 overflow-hidden rounded-md border border-gray-300 shadow flex-shrink-0" title="${card.name} (Lv ${card.level})">
                                <img src="${imageUrl}" alt="${card.name}" class="w-full h-full object-cover" onerror="this.onerror=null; this.src='https://placehold.co/40x40/cccccc/000000?text=Card'">
                            </div>
                            <span class="hidden sm:inline font-medium text-sm ml-2 truncate" title="${card.name}">${card.name}</span>
                        `;
                    } else {
                        const levelText = card.type === 'クライマックス' ? 'CX' : card.level;
                        cardInfo.innerHTML = `<div class="flex items-center w-full"><span class="font-bold text-gray-700 w-3 inline-block text-center mr-2 flex-shrink-0">${levelText}</span> <span class="card-name-text">${card.name}</span></div>`;
                    }

                    const locationGroup = document.createElement('div');
                    locationGroup.className = 'flex flex-nowrap gap-x-2 gap-y-1 location-radio-group';
                    locations.forEach(loc => {
                        const radioId = `card-${card.id}-loc-${loc.id}`;
                        locationGroup.innerHTML += `<input type="radio" id="${radioId}" name="card-location-${card.id}" value="${loc.id}" ${loc.id === 'deck' ? 'checked' : ''}><label for="${radioId}">${loc.name}</label>`;
                    });

                    cardRow.appendChild(cardInfo);
                    cardRow.appendChild(locationGroup);
                    deckListContainer.appendChild(cardRow);
                });
            }

            function updateCounters() {
                const counts = locations.reduce((acc, loc) => ({ ...acc, [loc.id]: 0 }), {});
                document.querySelectorAll('input[type="radio"]:checked').forEach(radio => counts[radio.value]++);
                locations.forEach(loc => document.getElementById(`count-${loc.id}`).textContent = counts[loc.id]);
                saveState();
            }
            
            function resetDeck() {
                let allRows = Array.from(deckListContainer.children);
                
                allRows.forEach(row => {
                    const deckRadio = row.querySelector('input[value="deck"]');
                    if (deckRadio) deckRadio.checked = true;
                });
                
                for (let i = allRows.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allRows[i], allRows[j]] = [allRows[j], allRows[i]];
                }
                
                deckListContainer.innerHTML = '';
                allRows.forEach(node => deckListContainer.appendChild(node));
                
                const initialHandElements = Array.from(deckListContainer.children).slice(0, 5); 
                initialHandElements.forEach(cardRow => {
                    const handRadio = cardRow.querySelector('input[value="hand"]');
                    if (handRadio) handRadio.checked = true;
                });

                updateCounters();
                saveState(); 
                showStatus('ゲームを初期化し、山札をシャッフル、上から5枚を手札にしました。', 'success');
            }

            function shuffleDeck() {
                const deckListRows = Array.from(deckListContainer.children);
                let deckNodes = deckListRows.filter(row => row.querySelector('input[value="deck"]:checked'));
                let otherNodes = deckListRows.filter(row => !row.querySelector('input[value="deck"]:checked'));
                for (let i = deckNodes.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deckNodes[i], deckNodes[j]] = [deckNodes[j], deckNodes[i]];
                }
                deckListContainer.innerHTML = '';
                otherNodes.forEach(node => deckListContainer.appendChild(node));
                deckNodes.forEach(node => deckListContainer.appendChild(node));
                updateCounters();
                saveState(); 
                showStatus('山札のカードのみをシャッフルしました。', 'success');
            }
            
            function loadDeckFromTextarea(shouldSave = true) {
                const csvData = deckInput.value;
                if (!csvData.trim()) return showStatus('デッキリストが入力されていません。', 'error');
                fullDeck = parseDeckData(csvData);
                if (fullDeck.length === 0) return showStatus('デッキリストの解析に失敗しました。', 'error');
                renderDeck(fullDeck);
                toggleExileVisibility(showExileToggle.checked);
                updateCounters();
                if (shouldSave) {
                    saveState(); 
                    showStatus(`デッキを読み込みました (合計 ${fullDeck.length} 枚)。`, 'success');
                }
            }

            function getLevelSortValue(card) {
                return card.type === 'クライマックス' ? 99 : parseInt(card.level, 10);
            }

            function sortHandToTop() {
                const allRows = Array.from(deckListContainer.children);
                const locationGroups = locations.reduce((acc, loc) => ({ ...acc, [loc.id]: [] }), {});
                allRows.forEach(row => {
                    const location = row.querySelector('input[type="radio"]:checked').value;
                    if (locationGroups[location]) locationGroups[location].push(row);
                });
                locationGroups.hand.sort((a, b) => getLevelSortValue({ level: a.dataset.cardLevel, type: a.dataset.cardType }) - getLevelSortValue({ level: b.dataset.cardLevel, type: b.dataset.cardType }));
                const sortedRows = locations.flatMap(loc => locationGroups[loc.id] || []);
                deckListContainer.innerHTML = '';
                sortedRows.forEach(node => deckListContainer.appendChild(node));
                saveState();
                showStatus('全てのカードを場所順に並び替え、手札のみレベル順でソートしました。', 'success');
            }

            function drawCard() {
                const topCardRow = Array.from(deckListContainer.children).find(row => row.querySelector('input[value="deck"]:checked'));
                if (!topCardRow) return showStatus('山札にカードがありません。', 'error');
                const handRadio = topCardRow.querySelector('input[value="hand"]');
                if (handRadio) handRadio.checked = true;
                updateCounters();
                showStatus(`${topCardRow.dataset.cardName} をドローしました。`, 'info');
            }

            function processDamage(damage) {
                const deckCards = Array.from(deckListContainer.children).filter(row => row.querySelector('input[value="deck"]:checked'));
                if (deckCards.length === 0) return showStatus('山札がありません。', 'error');
                let flippedCards = [], isCanceled = false;
                const maxFlip = Math.min(damage, deckCards.length);
                for (let i = 0; i < maxFlip; i++) {
                    flippedCards.push(deckCards[i]);
                    if (deckCards[i].dataset.cardType === 'クライマックス') { isCanceled = true; break; }
                }
                let targetLocation = isCanceled ? 'waiting' : 'clock';
                flippedCards.forEach(cardRow => {
                    const targetRadio = cardRow.querySelector(`input[value="${targetLocation}"]`);
                    if (targetRadio) targetRadio.checked = true;
                });
                updateCounters();
                let message = `${damage}点ダメージ！ ${flippedCards.length}枚目でCXが${isCanceled ? '出てキャンセル' : '出ず通りました'}。`;
                showStatus(message, isCanceled ? 'success' : 'error');
            }

            function levelUp() {
                const clockCards = Array.from(deckListContainer.children).filter(row => row.querySelector('input[value="clock"]:checked'));
                if (clockCards.length < 6) return showStatus(`クロックが6枚未満です。`, 'error');
                const cardsToMove = clockCards.slice(0, 6);
                cardsToMove.forEach(cardRow => {
                    const waitingRadio = cardRow.querySelector(`input[value="waiting"]`);
                    if (waitingRadio) waitingRadio.checked = true;
                });
                updateCounters(); 
                showStatus(`クロックの上から6枚を控え室に送りました。`, 'success');
            }
            
            function showCardModal(locationId) {
                const locationName = locations.find(loc => loc.id === locationId)?.name || locationId;
                modalTitle.textContent = `${locationName} のカード一覧`;
                modalContent.innerHTML = ''; 
                const targetCards = Array.from(deckListContainer.children).filter(row => row.querySelector(`input[value="${locationId}"]:checked`));
                
                if (targetCards.length === 0) {
                    modalContent.innerHTML = '<p class="text-gray-500">この場所には現在カードがありません。</p>';
                } else {
                    targetCards.forEach(cardRow => {
                        const { cardName, cardLevel, cardType, cardCode } = cardRow.dataset;
                        const cardElement = document.createElement('div');
                        cardElement.className = 'p-3 bg-white border border-gray-200 rounded-lg shadow-sm text-sm flex items-center';
                        
                        const isImageCard = isImageCardSupported(cardCode);
                        
                        if (isImageCard) {
                            const imageUrl = createCardImageUrl(cardCode);
                            cardElement.innerHTML = `
                                <div class="w-16 h-16 overflow-hidden rounded-md border border-gray-300 shadow mr-4 flex-shrink-0" title="${cardName} (Lv ${cardLevel})">
                                    <img src="${imageUrl}" alt="${cardName}" class="w-full h-full object-cover" onerror="this.onerror=null; this.src='https://placehold.co/64x64/cccccc/000000?text=Card'">
                                </div>
                                <span class="font-semibold text-gray-800 text-base">${cardName}</span>
                            `;
                        } else {
                            const levelText = cardType === 'クライマックス' ? 'CX' : cardLevel;
                            cardElement.innerHTML = `
                                <span class="font-bold text-gray-700 w-4 inline-block text-center mr-3 text-lg flex-shrink-0">${levelText}</span> 
                                <span class="font-semibold text-gray-800 text-base">${cardName}</span>
                            `;
                        }
                        modalContent.appendChild(cardElement);
                    });
                }
                cardModal.classList.remove('hidden'); cardModal.classList.add('flex');
            }

            function closeModal(modalElement) { modalElement.classList.add('hidden'); modalElement.classList.remove('flex'); }

            // --- Event Listeners ---
            loadDeckButton.addEventListener('click', () => loadDeckFromTextarea(true)); 
            shuffleButton.addEventListener('click', shuffleDeck);
            resetButton.addEventListener('click', resetDeck); 
            drawButton.addEventListener('click', drawCard); 
            sortHandButton.addEventListener('click', sortHandToTop); 
            levelUpButton.addEventListener('click', levelUp);
            document.getElementById('damage-2-button').addEventListener('click', (e) => processDamage(parseInt(e.target.dataset.damage)));
            document.getElementById('damage-3-button').addEventListener('click', (e) => processDamage(parseInt(e.target.dataset.damage)));
            deckListContainer.addEventListener('change', (event) => { if (event.target.type === 'radio') updateCounters(); });
            counterElements.forEach(counter => counter.addEventListener('click', () => showCardModal(counter.dataset.location)));
            
            // Modal Listeners
            closeCardModalButton.addEventListener('click', () => closeModal(cardModal));
            cardModal.addEventListener('click', (e) => { if (e.target === cardModal) closeModal(cardModal); });
            settingsButton.addEventListener('click', () => { settingsModal.classList.remove('hidden'); settingsModal.classList.add('flex'); });
            closeSettingsModalButton.addEventListener('click', () => closeModal(settingsModal));
            settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) closeModal(settingsModal); });
            
            showExileToggle.addEventListener('change', (e) => {
                toggleExileVisibility(e.target.checked);
                saveState(); 
            });

            // --- Initialization ---
            if (!loadState()) {
                deckInput.value = deckDataCSV.trim();
                loadDeckFromTextarea(false); 
                resetDeck(); 
            }
        });
    </script>
</body>
</html>

